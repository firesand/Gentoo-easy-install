#!/bin/bash
set -uo pipefail


################################################
# Initialize script environment

# Find the directory this script is stored in. (from: http://stackoverflow.com/questions/59895)
function get_source_dir() {
	local source="${BASH_SOURCE[0]}"
	while [[ -h $source ]]; do
		local tmp
		tmp="$(cd -P "$(dirname "${source}")" && pwd)"
		source="$(readlink "${source}")"
		[[ $source != /* ]] && source="${tmp}/${source}"
	done

	echo -n "$(realpath "$(dirname "${source}")")"
}

GENTOO_INSTALL_REPO_DIR="$(get_source_dir)"
export GENTOO_INSTALL_REPO_DIR
export GENTOO_INSTALL_REPO_SCRIPT_ACTIVE=true

# shellcheck source=./scripts/utils.sh
source "$GENTOO_INSTALL_REPO_DIR/scripts/utils.sh"

# Remember actual config file path
CONFIG_FILE="$(realpath "${1-"gentoo.conf"}" 2>/dev/null)"
RELA_CONFIG_FILE="$(realpath --relative-to="$(pwd)" "$CONFIG_FILE" 2>/dev/null)"

# Check if help is requested
while [[ $# -gt 0 ]]; do
	case "$1" in
		""|"help"|"--help"|"-help"|"-h")
			echo "Usage: $0 [config]"
			echo "Starts the gentoo configurator. If no file is given, it defaults to 'gentoo.conf'."
			echo "If the file doesn't exist, the configurator loads default values, otherwise, the"
			echo "the configuration is loaded into the configurator."
			exit 0
			;;
	esac
	shift
done

check_wanted_programs dialog ncurses=ncursesw6-config

# Determine whether EFI is available
HAS_EFI_SUPPORT=$([[ -d /sys/firmware/efi ]] && echo -n "true" || echo -n "false")
DEFAULT_BOOT_TYPE=$([[ $HAS_EFI_SUPPORT == true ]] && echo -n "efi" || echo -n "bios")
EFI_UNSUPPORTED_MESSAGE_SHORT="Missing EFI support on this system!"
EFI_UNSUPPORTED_MESSAGE="Apparently, your system does NOT support efi. Double-check before proceeding!"

# Wrap dialog in two functions to prevent it from cluttering stderr.
function dialog_wrapper() { dialog_out=$(command dialog --colors "$@" 3>&2 2>&1 1>&3 3>&-); }
function dialog() { dialog_wrapper "$@" 2>&1; }


################################################
# Configuration helper functions

function get_timezone() {
	local file
	if file="$(readlink /etc/localtime)"; then
		# /etc/localtime is a symlink as expected
		local timezone
		timezone=${file#*zoneinfo/}
		if [[ $timezone == "$file" ]]; then
			# not pointing to expected location or not Region/City
			echo "Europe/London"
		else
			echo "$timezone"
		fi
	else
		# compare files by contents
		find /usr/share/zoneinfo -type f -exec cmp -s {} /etc/localtime \; -print \
			| sed -e 's,.*/zoneinfo/,,' \
			| head -1
	fi
}

function get_default_keymap() {
	local keymap
	keymap="$(grep KEYMAP /etc/vconsole.conf 2>/dev/null || echo "KEYMAP=us")"
	keymap="${keymap#KEYMAP=}"

	local map
	for map in "${ALL_KEYMAPS[@]}"; do
		if [[ $map == "$keymap" ]]; then
			echo -n "${keymap}"
			return
		fi
	done

	# Fallback to us
	echo -n "us"
}

function get_all_keymaps() {
	ALL_KEYMAPS=()
	local map
	for map in $(find /usr/share/keymaps/ /usr/share/kbd/keymaps/ -type f -iname '*.map.gz' -printf "%f\n" 2>/dev/null | sort -u); do
		ALL_KEYMAPS+=("${map%%.map.gz}")
	done
}

function get_all_timezones() {
	einfo "Detecting available timezones..."
	
	# Check if /usr/share/zoneinfo exists
	if [[ ! -d "/usr/share/zoneinfo" ]]; then
		ewarn "/usr/share/zoneinfo directory not found!"
		ALL_TIMEZONES=()
		return 1
	fi
	
	# Try to find timezone files
	local timezone_files
	timezone_files=$(find /usr/share/zoneinfo -type f -printf "%P\n" 2>/dev/null | sort -u)
	
	if [[ -z "$timezone_files" ]]; then
		ewarn "No timezone files found in /usr/share/zoneinfo"
		ALL_TIMEZONES=()
		return 1
	fi
	
	# Convert to array
	readarray -t ALL_TIMEZONES < <(echo "$timezone_files")
	
	einfo "Successfully detected ${#ALL_TIMEZONES[@]} timezones"
	
	# Debug: Show first few timezones
	if [[ ${#ALL_TIMEZONES[@]} -gt 0 ]]; then
		einfo "Sample timezones: ${ALL_TIMEZONES[*]:0:5}"
	fi
	
	# If still no timezones, provide a fallback list
	if [[ ${#ALL_TIMEZONES[@]} -eq 0 ]]; then
		ewarn "Using fallback timezone list"
		ALL_TIMEZONES=(
			"UTC"
			"Europe/London"
			"Europe/Paris"
			"Europe/Berlin"
			"Europe/Rome"
			"Europe/Madrid"
			"Europe/Amsterdam"
			"Europe/Brussels"
			"Europe/Vienna"
			"Europe/Zurich"
			"Europe/Stockholm"
			"Europe/Oslo"
			"Europe/Copenhagen"
			"Europe/Helsinki"
			"Europe/Warsaw"
			"Europe/Prague"
			"Europe/Budapest"
			"Europe/Bucharest"
			"Europe/Sofia"
			"Europe/Athens"
			"Europe/Istanbul"
			"Europe/Moscow"
			"Asia/Tokyo"
			"Asia/Shanghai"
			"Asia/Seoul"
			"Asia/Singapore"
			"Asia/Hong_Kong"
			"Asia/Bangkok"
			"Asia/Jakarta"
			"Asia/Manila"
			"Asia/Kolkata"
			"Asia/Dubai"
			"Asia/Tehran"
			"Asia/Jerusalem"
			"Africa/Cairo"
			"Africa/Lagos"
			"Africa/Johannesburg"
			"Africa/Nairobi"
			"America/New_York"
			"America/Chicago"
			"America/Denver"
			"America/Los_Angeles"
			"America/Toronto"
			"America/Vancouver"
			"America/Mexico_City"
			"America/Sao_Paulo"
			"America/Buenos_Aires"
			"Australia/Sydney"
			"Australia/Melbourne"
			"Australia/Perth"
			"Pacific/Auckland"
			"Pacific/Honolulu"
		)
		einfo "Fallback timezone list loaded with ${#ALL_TIMEZONES[@]} timezones"
	fi
}

function recalculate_locales() {
	LOCALES=""
	N_LOCALES=0

	local selected_index_list="$SELECTED_LOCALES"
	local next_selected
	next_selected="${selected_index_list%% *}"
	selected_index_list="${selected_index_list#* }"

	local i=0
	for item in "${SUPPORTED_LOCALES[@]}"; do
		if [[ "$i" == "$next_selected" ]]; then
			LOCALES="$LOCALES"$'\n'"$item"
			next_selected="${selected_index_list%% *}"
			selected_index_list="${selected_index_list#* }"
			((++N_LOCALES))
		fi
		((++i))
	done

	LOCALES="${LOCALES:1}"
}

function define_disk_configuration_function() {
	cat << EOF
function disk_configuration() {
	$* ;
}
EOF
}

function define_swap() {
	if [[ $PARTITIONING_USE_SWAP == "true" ]]; then
		echo -n "${PARTITIONING_SWAP@Q}"
	else
		echo -n "false"
	fi
}

function define_zfs_compression() {
	if [[ $PARTITIONING_ZFS_USE_COMPRESSION != "false" ]]; then
		echo -n "${PARTITIONING_ZFS_COMPRESSION@Q}"
	else
		echo -n "false"
	fi
}

function define_disk_layout() {
	local swapdev
	case "$PARTITIONING_SCHEME" in
		"classic_single_disk") define_disk_configuration_function "create_classic_single_disk_layout swap=$(define_swap) type=${PARTITIONING_BOOT_TYPE@Q} luks=${PARTITIONING_USE_LUKS@Q} root_fs=${PARTITIONING_ROOT_FS@Q}" "${PARTITIONING_DEVICE@Q}" ;;
		"existing_partitions")
			if [[ "$PARTITIONING_USE_SWAP" ]]; then
				swapdev=${PARTITIONING_SWAP_DEVICE:-false}
			else
				swapdev=false
			fi
		    define_disk_configuration_function "create_existing_partitions_layout boot=${PARTITIONING_BOOT_DEVICE@Q} swap=${swapdev@Q} type=${PARTITIONING_BOOT_TYPE@Q}" "${PARTITIONING_DEVICE@Q}" ;;
		"zfs_centric")         define_disk_configuration_function "create_zfs_centric_layout swap=$(define_swap) type=${PARTITIONING_BOOT_TYPE@Q} encrypt=${PARTITIONING_ZFS_USE_ENCRYPTION@Q} compress=$(define_zfs_compression) pool_type=${PARTITIONING_ZFS_POOL_TYPE@Q}" "${PARTITIONING_DEVICES[@]@Q}" ;;
		"btrfs_centric")       define_disk_configuration_function "create_btrfs_centric_layout swap=$(define_swap) type=${PARTITIONING_BOOT_TYPE@Q} raid_type=${PARTITIONING_BTRFS_RAID_TYPE@Q} luks=${PARTITIONING_USE_LUKS@Q}" "${PARTITIONING_DEVICES[@]@Q}" ;;
		"raid0_luks")          define_disk_configuration_function "create_raid0_luks_layout swap=$(define_swap) type=${PARTITIONING_BOOT_TYPE@Q} luks=${PARTITIONING_USE_LUKS@Q} root_fs=${PARTITIONING_ROOT_FS@Q}" "${PARTITIONING_DEVICES[@]@Q}" ;;
		"raid1_luks")          define_disk_configuration_function "create_raid1_luks_layout swap=$(define_swap) type=${PARTITIONING_BOOT_TYPE@Q} luks=${PARTITIONING_USE_LUKS@Q} root_fs=${PARTITIONING_ROOT_FS@Q}" "${PARTITIONING_DEVICES[@]@Q}" ;;
		"custom")
			# Show current function declaration, trim trailing whitespace
			declare -f disk_configuration \
				| sed -e 's/\s*$//'
			;;
	esac
}

ALL_GENTOO_ARCHS=("x86" "amd64" "arm" "arm64")
ALL_GENTOO_SUBARCHS=("i486" "i686")
ALL_STAGE3_VARIANTS=(
	"openrc"                   "openrc                  | Minimal OpenRC base (recommended)"
	"openrc-splitusr"          "openrc-splitusr         | Minimal OpenRC base with a split-usr filesystem layout"
	"desktop-openrc"           "openrc-desktop          | OpenRC, desktop profile, might have blockers"
	"systemd"                  "systemd                 | Minimal systemd base (recommended)"
	"desktop-systemd"          "systemd-desktop         | systemd, desktop profile, might have blockers"
	"nomultilib-openrc"        "nomultilib-openrc       | Minimal OpenRC base without 32bits support (Experimental)"
	"nomultilib-systemd"       "nomultilib-systemd      | Minimal systemd base without 32bits support (Experimental)"
	"x32-openrc"               "x32-openrc              | Minimal OpenRC base without 64bits support (Experimental)"
	"x32-systemd"              "x32-systemd             | Minimal systemd base without 64bits support (Experimental)"
	"llvm-openrc"              "llvm-openrc             | Minimal OpenRC base compiled with LLVM (Experimental)"
	"llvm-systemd"             "llvm-systemd            | Minimal systemd base compiled with LLVM (Experimental)"
	"hardened-openrc"          "hardened-openrc         | Hardened OpenRC base (Experimental)"
	"hardened-selinux-openrc"  "hardened-selinux-openrc | Hardened OpenRC base with SELinux (Experimental)"
	"musl"                     "musl-openrc             | Minimal OpenRC base using musl (Experimental)"
	"musl-llvm"                "musl-llvm-openrc        | Minimal OpenRC base using musl compiled with LLVM (Experimental)"
	"musl-hardened"            "musl-hardened-openrc    | Hardened OpenRC base using musl (Experimental)"
)

ALL_PARTITIONING_SCHEMES=(
	"classic_single_disk" "Classic single disk layout (boot/efi, swap?, root)"
	"existing_partitions" "Skip partitioning, use existing pre-formatted partitions"
	"zfs_centric"         "ZFS centric (optional ZFS compression and encryption)"
	"btrfs_centric"       "Btrfs centric (optional raid0/1 via btrfs)"
	"raid0_luks"          "Raid0 (N>=2 disks) and luks for root"
	"raid1_luks"          "Raid1 (N>=2 disks) and luks for root"
	"custom"              "Custom (expert option; edit the config manually later)"
)

PARTITIONING_BOOT_TYPES=(
	"efi" "efi$([[ $HAS_EFI_SUPPORT == true ]] && echo -n "" || echo -n " (!! $EFI_UNSUPPORTED_MESSAGE_SHORT !!)")"
	"bios" "bios"
)
PARTITIONING_ROOT_FS_TYPES=("ext4" "btrfs")
PARTITIONING_BTRFS_RAID_TYPES=("raid0" "raid1")
PARTITIONING_ZFS_POOL_TYPES=("standard" "custom")
PARTITIONING_ZFS_COMPRESSIONS=("on" "gzip" "lz4" "lzjb" "zle" "zstd" "zstd-fast")

PORTAGE_SYNC_TYPES=("git" "rsync")

function create_single_disk_layout() {
	create_classic_single_disk_layout "$@"
}

function parse_swap() {
	if [[ $1 == "false" ]]; then
		PARTITIONING_USE_SWAP=false
		PARTITIONING_SWAP=8GiB
	else
		PARTITIONING_USE_SWAP=true
		PARTITIONING_SWAP="$1"
	fi
}

function parse_zfs_compression() {
	if [[ $1 == "false" ]]; then
		PARTITIONING_ZFS_USE_COMPRESSION=false
		PARTITIONING_ZFS_COMPRESSION=zstd
	else
		PARTITIONING_ZFS_USE_COMPRESSION=true
		PARTITIONING_ZFS_COMPRESSION="$1"
	fi
}

function create_classic_single_disk_layout() {
	PARTITIONING_SCHEME="classic_single_disk"

	local known_arguments=('+swap' '?type' '?luks' '?root_fs')
	local extra_arguments=()
	declare -A arguments; parse_arguments "$@"

	PARTITIONING_DEVICE="${extra_arguments[0]}"
	parse_swap "${arguments[swap]}"
	PARTITIONING_BOOT_TYPE="${arguments[type]}"
	PARTITIONING_USE_LUKS="${arguments[luks]:-false}"
	PARTITIONING_ROOT_FS="${arguments[root_fs]:-ext4}"
}

function create_existing_partitions_layout() {
	PARTITIONING_SCHEME="existing_partitions"

	local known_arguments=('+swap' '+boot' '?type')
	local extra_arguments=()
	declare -A arguments; parse_arguments "$@"

	PARTITIONING_DEVICE="${extra_arguments[0]}"
	if [[ "${arguments[swap]}" == "false" ]]; then
		PARTITIONING_USE_SWAP=false
		PARTITIONING_SWAP_DEVICE=""
	else
		PARTITIONING_USE_SWAP=true
		PARTITIONING_SWAP_DEVICE="${arguments[swap]}"
	fi
	PARTITIONING_BOOT_TYPE="${arguments[type]}"
	PARTITIONING_BOOT_DEVICE="${arguments[boot]}"
}

function create_raid0_luks_layout() {
	PARTITIONING_SCHEME="raid0_luks"

	local known_arguments=('+swap' '?type' '?luks' '?root_fs')
	local extra_arguments=()
	declare -A arguments; parse_arguments "$@"

	PARTITIONING_DEVICES=("${extra_arguments[@]}")
	parse_swap "${arguments[swap]}"
	PARTITIONING_BOOT_TYPE="${arguments[type]}"
	PARTITIONING_USE_LUKS="${arguments[luks]:-true}"
	PARTITIONING_ROOT_FS="${arguments[root_fs]:-ext4}"
}

function create_raid1_luks_layout() {
	PARTITIONING_SCHEME="raid1_luks"

	local known_arguments=('+swap' '?type' '?luks' '?root_fs')
	local extra_arguments=()
	declare -A arguments; parse_arguments "$@"

	PARTITIONING_DEVICES=("${extra_arguments[@]}")
	parse_swap "${arguments[swap]}"
	PARTITIONING_BOOT_TYPE="${arguments[type]}"
	PARTITIONING_USE_LUKS="${arguments[luks]:-true}"
	PARTITIONING_ROOT_FS="${arguments[root_fs]:-ext4}"
}

function create_zfs_centric_layout() {
	PARTITIONING_SCHEME="zfs_centric"

	local known_arguments=('+swap' '?type' '?pool_type' '?encrypt' '?compress')
	local extra_arguments=()
	declare -A arguments; parse_arguments "$@"

	PARTITIONING_DEVICES=("${extra_arguments[@]}")
	parse_swap "${arguments[swap]}"
	PARTITIONING_BOOT_TYPE="${arguments[type]}"
	PARTITIONING_ZFS_POOL_TYPE="${arguments[pool_type]:-standard}"
	PARTITIONING_ZFS_USE_ENCRYPTION="${arguments[encrypt]:-false}"
	parse_zfs_compression "${arguments[compress]:-false}"
}

function create_btrfs_raid_layout() {
	create_btrfs_centric_layout "$@"
}

function create_btrfs_centric_layout() {
	PARTITIONING_SCHEME="btrfs_centric"

	# shellcheck disable=SC2034
	local known_arguments=('+swap' '?type' '?raid_type' '?luks')
	local extra_arguments=()
	declare -A arguments; parse_arguments "$@"

	PARTITIONING_DEVICES=("${extra_arguments[@]}")
	parse_swap "${arguments[swap]}"
	PARTITIONING_BOOT_TYPE="${arguments[type]}"
	PARTITIONING_USE_LUKS="${arguments[luks]:-false}"
	PARTITIONING_BTRFS_RAID_TYPE="${arguments[raid_type]:-raid0}"
}


################################################
# Configuration constants

get_all_keymaps
get_all_timezones
readarray -t SUPPORTED_LOCALES < "$GENTOO_INSTALL_REPO_DIR/contrib/i18n_supported"
readarray -t LOCALE_A < <(locale -a)


################################################
# Load/Default configuration

function load_selected_locales() {
	local sel_locales=()
	local IFS=$'\n'
	declare -A selected_by_name
	for i in $LOCALES; do
		selected_by_name["$i"]=true
	done

	local i=0
	for item in "${SUPPORTED_LOCALES[@]}"; do
		[[ "${selected_by_name[$item]:-}" == true ]] \
			&& sel_locales+=("$i")
		((++i))
	done

	local IFS=" "
	SELECTED_LOCALES="${sel_locales[*]}"
}

function process_config() {
	disk_configuration

	if [[ "$KEYMAP" == "$KEYMAP_INITRAMFS" ]]; then
		KEYMAP_INITRAMFS_OTHER=false
	else
		KEYMAP_INITRAMFS_OTHER=true
	fi

	load_selected_locales
	recalculate_locales
}

function load_config() {
	# First load defaults, then replace by sourcing config.
	load_default_config

	# Fallback to custom partitioning scheme if it isn't set in the actual config
	PARTITIONING_SCHEME="custom"

	# Load settings
	# shellcheck disable=SC1090
	source "$1" || die "Could not load given configuration."

	# After loading a config, no unsaved changes exist.
	UNSAVED_CHANGES=false
}

function load_default_config() {
	HOSTNAME="gentoo"
	TIMEZONE="$(get_timezone)"
	KEYMAP="$(get_default_keymap)"
	KEYMAP_INITRAMFS="$KEYMAP"
	LOCALES="C.UTF-8 UTF-8"
	LOCALE="C.UTF-8"

	SYSTEMD_NETWORKD=true
	SYSTEMD_NETWORKD_INTERFACE_NAME="en*"
	SYSTEMD_NETWORKD_DHCP=true
	SYSTEMD_NETWORKD_ADDRESSES=("192.168.1.100/32" "fd00::1/64")
	SYSTEMD_NETWORKD_GATEWAY="192.168.1.1"
	SYSTEMD_INITRAMFS_SSHD=false

	function disk_configuration() {
		#create_zfs_centric_layout swap=8GiB type="$DEFAULT_BOOT_TYPE" encrypt=true compress=zstd pool_type=standard /dev/sdX
		create_classic_single_disk_layout swap=8GiB type="$DEFAULT_BOOT_TYPE" luks=true root_fs=ext4 /dev/sdX
	}

	STAGE3_VARIANT="systemd"
	PORTAGE_SYNC_TYPE="git"
	PORTAGE_GIT_FULL_HISTORY=false
	PORTAGE_GIT_MIRROR="https://anongit.gentoo.org/git/repo/sync/gentoo.git"

	GENTOO_MIRROR="https://mirror.leaseweb.com/gentoo"
	GENTOO_ARCH="amd64"
	GENTOO_SUBARCH=""

	USE_PORTAGE_TESTING=true
	SELECT_MIRRORS=false
	SELECT_MIRRORS_LARGE_FILE=false

	ADDITIONAL_PACKAGES=()
	ENABLE_SSHD=true
	ENABLE_BINPKG=false
	ROOT_SSH_AUTHORIZED_KEYS=""

	# Desktop Environment Configuration
	DESKTOP_ENVIRONMENT=""
	DESKTOP_ADDITIONAL_PACKAGES=()
	ENABLE_DISPLAY_MANAGER="auto"
	ENABLE_NETWORK_MANAGER="auto"

	# GPU Driver Configuration
	GPU_DRIVER=""
	GPU_DRIVER_ADDITIONAL_PACKAGES=()
	ENABLE_VULKAN=true
	ENABLE_OPENCL=false

	# Performance & Testing Configuration
	ENABLE_PERFORMANCE_OPTIMIZATION=true
	ENABLE_VM_TESTING_TOOLS=true
	ENABLE_DISPLAY_BACKEND_TESTING=true
	ENABLE_GPU_BENCHMARKING=false

	# Package Management Configuration
	PACKAGE_USE_RULES=()
	PACKAGE_KEYWORDS=()
	ACCEPT_KEYWORDS=()
	OVERLAY_URLS=()
	OVERLAY_NAMES=()

	# All settings are unsaved.
	UNSAVED_CHANGES=true
}

SAVE_AS_FILENAME="$RELA_CONFIG_FILE"
if [[ -e "$CONFIG_FILE" ]]; then
	load_config "$CONFIG_FILE"
else
	load_default_config
fi
process_config


################################################
# Menu helpers and constants

# $1: exit code
function clear_and_exit() {
	dialog --clear
	clear -x
	exit "$1"
}

function ellipsis() {
	local len="$1"
	shift
	local str="$*"
	if [[ "${#str}" -gt "$len" ]]; then
		echo "${str:0:$len}…"
	else
		echo "$str"
	fi
}

function on_off_toggle() {
	if [[ "${!1}" == true ]]; then
		declare -g "$1"=false
	else
		declare -g "$1"=true
	fi
}

function on_off_str() {
	if [[ "$1" == true ]]; then
		echo -n "$2"
	else
		echo -n "$3"
	fi
}

function on_off_label() {
	local prefix="${2:-}"
	on_off_str "$1" "${prefix}[*]" "${prefix}[ ]"
}

function on_off_label_inverted() {
	local var=$1
	shift
	on_off_label "$(is_on "$var" && echo false || echo true)" "$@"
}

function is_on() {
	[[ "$1" == true ]]
}

function is_off() {
	[[ "$1" != true ]]
}

# if $1 is in $2..
function one_of() {
	local what="$1"
	shift
	for i in "$@"; do
		[[ "$i" == "$what" ]] \
			&& return 0
	done
	return 1
}

# $1: title
# $2: description
# $3: space separated index list of selected items (e.g. "0 1 5 6")
# $@: all items
function menu_splitlist() {
	local title="$1"
	local description="$2"
	local selected_index_list="$3"
	shift 3

	# Build option array
	local items=()
	local item
	local i=0
	local next_selected="${selected_index_list%% *}"
	local selected_index_list="${selected_index_list#* }"
	for item in "$@"; do
		if [[ "$i" == "$next_selected" ]]; then
			items+=("$i" "$item" "on")
			next_selected="${selected_index_list%% *}"
			selected_index_list="${selected_index_list#* }"
		else
			items+=("$i" "$item" "off")
		fi
		((++i))
	done

	# Show selection dialog
	dialog \
		--title "$title" \
		--buildlist "$description\nUse ^ to focus the list of unselected items and $ to focus the list of selected items. Use <Space> to select/deselect an item and select <OK> by pressing <Enter> when finished." \
		"${BUILDLIST_SIZE[@]}" "${items[@]}"

	local diag_exit=$?
	if [[ $diag_exit == 0 ]]; then
		# <OK>
		return 0
	elif [[ $diag_exit == 1 ]]; then
		# <Cancel>
		return 1
	else
		# <ESC><ESC>
		return 1
	fi
}

# $1: title
# $2: description
# $3: default item
# $@: [tag label]...
function menu_radiolist_labeled() {
	local title="$1"
	local description="$2"
	local default_item="$3"
	shift 3

	# Build option array
	local items=()
	local tag
	local label
	while [[ "$#" -gt 0 ]]; do
		tag="$1"
		label="$2"
		shift 2

		if [[ $tag == "$default_item" ]]; then
			items+=("$tag" "$label" "on")
		else
			items+=("$tag" "$label" "off")
		fi
	done

	# Show selection dialog
	dialog \
		--no-tags \
		--title "$title" \
		--help-button \
		--help-label "Select" \
		--help-status \
		--ok-label "OK" \
		--default-item "$default_item" \
		--default-button help \
		--radiolist "$description\nUse <Select> to select the option under the cursor, or <OK> to use the option which is selected with an asterisk." \
		"${RADIOLIST_SIZE[@]}" "${items[@]}"

	local diag_exit=$?
	if [[ $diag_exit == 0 ]]; then
		# <OK>
		return 0
	elif [[ $diag_exit == 1 ]]; then
		# <Cancel>
		return 1
	elif [[ $diag_exit == 2 ]]; then
		# <Select>
		local sel="${dialog_out#HELP }"
		local sel_cur="${sel% *}"
		#local sel_radio="${sel#* }"
		dialog_out="$sel_cur"
		return 0
	else
		# <ESC><ESC>
		return 1
	fi
}

# $1: title
# $2: description
# $3: default item
# $@: items
function menu_radiolist() {
	local title="$1"
	local description="$2"
	local default_item="$3"
	shift 3

	# Build option array
	local items=()
	local item
	for item in "$@"; do
		if [[ $item == "$default_item" ]]; then
			items+=("$item" "on")
		else
			items+=("$item" "off")
		fi
	done

	# Show selection dialog
	dialog \
		--no-items \
		--title "$title" \
		--help-button \
		--help-label "Select" \
		--help-status \
		--ok-label "OK" \
		--default-item "$default_item" \
		--default-button help \
		--radiolist "$description\nUse <Select> to select the option under the cursor, or <OK> to use the option which is selected with an asterisk." \
		"${RADIOLIST_SIZE[@]}" "${items[@]}"

	local diag_exit="$?"
	if [[ $diag_exit == 0 ]]; then
		# <OK>
		return 0
	elif [[ $diag_exit == 1 ]]; then
		# <Cancel>
		return 1
	elif [[ $diag_exit == 2 ]]; then
		# <Select>
		local sel="${dialog_out#HELP }"
		local sel_cur="${sel% *}"
		#local sel_radio="${sel#* }"
		dialog_out="$sel_cur"
		return 0
	else
		# <ESC><ESC>
		return 1
	fi
}

# $1: title
# $2: description
# $3: current device (will be canonicalized if possible)
function menu_select_device() {
	local title="$1"
	local desc="$2"
	local prev_selected
	prev_selected=$(canonicalize_device "$3")

	while true; do
		local all_devices=()
		for dev in /dev/disk/by-id/*; do
			all_devices+=("$dev" "$(basename "$dev")")
		done
		all_devices+=("/dev/null" "<enter custom path>")

		if menu_radiolist_labeled "$title" "$desc" "$prev_selected" "${all_devices[@]}"; then
			if [[ "$dialog_out" == "/dev/null" ]]; then
				while true; do
					if dialog \
						--title "$1" \
						--inputbox "$([[ -e $prev_selected ]] || echo -n "\Z1The previously selected device $prev_selected does not exist!\Zn ")Enter the path of the desired device." \
						"${INPUTBOX_SIZE[@]}" "$prev_selected"
					then
						# Repeat until selected device exists or cancelled
						prev_selected="$dialog_out"
						[[ ! -e "$dialog_out" ]] && continue
						return 0
					else
						# <Cancel> -> return to previous menu
						break
					fi
				done

				# Return to radiolist
				continue
			else
				return 0
			fi
		else
			# <Cancel>
			return 1
		fi
	done
}

function msgbox_help() {
	dialog --msgbox "$1" "${HELP_POPUP_SIZE[@]}"
}

function menu_exit() {
	if [[ $UNSAVED_CHANGES == "true" ]]; then
		dialog \
			--help-button --help-label "Back" \
			--yes-label "Save" --no-label "Discard" \
			--yesno "Do you want to save your configuration?\n(Press <ESC><ESC>, or choose <Back> to continue gentoo configuration)." \
			"${CONFIRM_SIZE[@]}"

		local diag_exit="$?"
		if [[ $diag_exit == 0 ]]; then
			# <Save>
			save "$CONFIG_FILE"
			clear_and_exit 0
		elif [[ $diag_exit == 1 ]]; then
			# <Discard>
			clear_and_exit 0
		else
			# Back to menu (<ESC><ESC>, <Back>)
			true
		fi
	else
		# Nothing was changed. Exit immediately.
		clear_and_exit 0
	fi
}

function menu_save_as() {
	dialog \
		--ok-label "Save" \
		--inputbox "Enter a filename to which this configuration should be saved.\n(Press <ESC><ESC>, or choose <Cancel> to abort)." \
		"${INPUTBOX_SIZE[@]}" "$SAVE_AS_FILENAME"

	local diag_exit="$?"
	if [[ $diag_exit == 0 ]]; then
		# <Save>
		SAVE_AS_FILENAME="$dialog_out"
		save "$SAVE_AS_FILENAME"
		UNSAVED_CHANGES=false
	else
		# Back to menu (<ESC><ESC>, <Cancel>)
		true
	fi
}

function menu() {
	local item
	local item_tag
	local tag_item_list=()
	declare -A reverse_lookup

	# Create menu list
	for item in "${MENU_ITEMS[@]}"; do
		# Only if item is visible
		"${item}_show" || continue

		item_tag="$("${item}_tag")"
		tag_item_list+=("$item_tag" "$("${item}_label")")
		reverse_lookup["$item_tag"]="$item"
	done

	dialog --colors \
		--title "Gentoo configuration ($RELA_CONFIG_FILE)" \
		--extra-button --extra-label "Exit" \
		--help-button \
		--default-item "$SELECTED_MENU_ITEM" \
		--ok-label "Select" --cancel-label "Save" \
		--menu "This is the gentoo configuration menu. Read and adjust all options below carefully. Save your desired configuration and run ./install afterwards. Use <Help> if you want further information on any option." \
		"${MENU_SIZE[@]}" "${tag_item_list[@]}"

	local diag_exit="$?"
	if [[ $diag_exit == 0 ]]; then
		# <Select>
		SELECTED_MENU_ITEM="$dialog_out"
		[[ -z "$SELECTED_MENU_ITEM" ]] \
			|| "${reverse_lookup[$SELECTED_MENU_ITEM]}_menu"
	elif [[ $diag_exit == 1 ]]; then
		# <Save>
		SELECTED_MENU_ITEM="$dialog_out"
		menu_save_as
	elif [[ $diag_exit == 2 ]]; then
		# <Help>
		SELECTED_MENU_ITEM="${dialog_out#HELP }"
		msgbox_help "$("${reverse_lookup[$SELECTED_MENU_ITEM]}_help")"
	else
		# Exit (<ESC><ESC>, <Exit>)
		SELECTED_MENU_ITEM="${dialog_out:-$SELECTED_MENU_ITEM}"
		menu_exit
		true
	fi
}

function init_menu_size() {
	local cols
	local rows
	cols=$(tput cols)  || cols=80
	rows=$(tput lines) || rows=24

	local max_h=$((rows - 3))
	local max_w=$((cols - 6))

	SELECTED_MENU_ITEM=""
	MENU_SIZE=("$max_h" "$max_w" "$((max_h - 8))")
	INPUTBOX_SIZE=("11" "$max_w")
	EDITTEXT_SIZE=("$max_h" "$max_w")
	RADIOLIST_SIZE=("$max_h" "$max_w" "$((max_h - 12))")
	BUILDLIST_SIZE=("$max_h" "$max_w" "$((max_h - 12))")
	HELP_POPUP_SIZE=("$((max_h - 12))" "$((max_w - 10))")
	CONFIRM_SIZE=("8" "66")
}

#SELECTED_MENU_ITEM=""
#MENU_SIZE=("20" "76" "12")
#INPUTBOX_SIZE=("11" "76")
#EDITTEXT_SIZE=("16" "76")
#RADIOLIST_SIZE=("20" "76" "8")
#BUILDLIST_SIZE=("20" "76" "8")
#HELP_POPUP_SIZE=("8" "66")
#CONFIRM_SIZE=("8" "66")
init_menu_size


################################################
# Menu definition

MENU_ITEMS=(
	"PARTITIONING_SCHEME"
	"PARTITIONING_BOOT_TYPE"
	"PARTITIONING_BOOT_DEVICE"
	"PARTITIONING_USE_SWAP"
	"PARTITIONING_SWAP"
	"PARTITIONING_SWAP_DEVICE"
	"PARTITIONING_ROOT_FS"
	"PARTITIONING_USE_LUKS"
	"PARTITIONING_ZFS_POOL_TYPE"
	"PARTITIONING_ZFS_USE_ENCRYPTION"
	"PARTITIONING_ZFS_USE_COMPRESSION"
	"PARTITIONING_ZFS_COMPRESSION"
	"PARTITIONING_BTRFS_RAID_TYPE"
	"PARTITIONING_DEVICE"
	"PARTITIONING_DEVICES"
	"--------"
	"HOSTNAME"
	"TIMEZONE"
	"KEYMAP"
	"KEYMAP_INITRAMFS_OTHER"
	"KEYMAP_INITRAMFS"
	"LOCALES"
	"LOCALE"
	"SYSTEMD_NETWORKD"
	"SYSTEMD_INITRAMFS_SSHD"
	"SYSTEMD_NETWORKD_INTERFACE_NAME"
	"SYSTEMD_NETWORKD_DHCP"
	"SYSTEMD_NETWORKD_ADDRESSES"
	"SYSTEMD_NETWORKD_GATEWAY"
	"--------"
	"STAGE3_VARIANT"
	"PORTAGE_SYNC_TYPE"
	"PORTAGE_GIT_FULL_HISTORY"
	"PORTAGE_GIT_MIRROR"
	"GENTOO_MIRROR"
	"GENTOO_ARCH"
	"GENTOO_SUBARCH"
	"USE_PORTAGE_TESTING"
	"SELECT_MIRRORS"
	"SELECT_MIRRORS_LARGE_FILE"
	"--------"
	"ENABLE_SSHD"
	"ENABLE_BINPKG"
	"ROOT_SSH_AUTHORIZED_KEYS"
	"--------"
	"DESKTOP_ENVIRONMENT"
	"DESKTOP_ADDITIONAL_PACKAGES"
	"ENABLE_DISPLAY_MANAGER"
	"ENABLE_NETWORK_MANAGER"
	"--------"
	"GPU_DRIVER"
	"GPU_DRIVER_ADDITIONAL_PACKAGES"
	"ENABLE_VULKAN"
	"ENABLE_OPENCL"
	"--------"
	"ENABLE_PERFORMANCE_OPTIMIZATION"
	"ENABLE_VM_TESTING_TOOLS"
	"ENABLE_DISPLAY_BACKEND_TESTING"
	"ENABLE_GPU_BENCHMARKING"
	"--------"
	"PACKAGE_USE_RULES"
	"PACKAGE_KEYWORDS"
	"ACCEPT_KEYWORDS"
	"OVERLAY_MANAGER"
	"--------"
	"ADDITIONAL_PACKAGES"
)

function --------_tag()   { echo "────────────────────────────"; }
function --------_label() { echo "────────────────────────────"; }
function --------_show()  { return 0; }
function --------_help()  { echo "Congratulations, you found a separator."; }
function --------_menu()  { true; }

function PARTITIONING_SCHEME_tag()   { echo "Partitioning scheme"; }
function PARTITIONING_SCHEME_label() { echo "($PARTITIONING_SCHEME)"; }
function PARTITIONING_SCHEME_show()  { return 0; }
function PARTITIONING_SCHEME_help()  { echo "Select the desired partitioning scheme."; }
function PARTITIONING_SCHEME_menu()  {
	if menu_radiolist_labeled \
		"Select partitioning scheme" \
		"Select which partitioning scheme you want to follow. Have a look at the help text for this option (available in the menu) for more details.\n\nAll options support EFI/BIOS, swap and some form of encryption (luks/zfs).\n" \
		"$PARTITIONING_SCHEME" \
		"${ALL_PARTITIONING_SCHEMES[@]}"
	then
		# Set disk scheme
		case "$dialog_out" in
			"classic_single_disk") create_classic_single_disk_layout swap=8GiB type="$DEFAULT_BOOT_TYPE" luks=false root_fs=ext4 /dev/sdX ;;
			"existing_partitions") create_existing_partitions_layout boot=/dev/sdA swap=false type="$DEFAULT_BOOT_TYPE" /dev/sdX ;;
			"zfs_centric")         create_zfs_centric_layout swap=8GiB type="$DEFAULT_BOOT_TYPE" encrypt=true compress=zstd pool_type=standard /dev/sdX ;;
			"btrfs_centric")       create_btrfs_centric_layout swap=8GiB type="$DEFAULT_BOOT_TYPE" raid_type=raid0 luks=false /dev/sdX ;;
			"raid0_luks")          create_raid0_luks_layout swap=8GiB type="$DEFAULT_BOOT_TYPE" luks=true root_fs=ext4 /dev/sdX /dev/sdY ;;
			"raid1_luks")          create_raid1_luks_layout swap=8GiB type="$DEFAULT_BOOT_TYPE" luks=true root_fs=ext4 /dev/sdX /dev/sdY ;;
			"custom")              PARTITIONING_SCHEME="$dialog_out" ;;
		esac
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_BOOT_TYPE_tag()   { echo " ├ Boot type"; }
function PARTITIONING_BOOT_TYPE_label() { echo " ├ ($PARTITIONING_BOOT_TYPE)$([[ $PARTITIONING_BOOT_TYPE == efi && $HAS_EFI_SUPPORT == false ]] && echo -n " \Z1$EFI_UNSUPPORTED_MESSAGE_SHORT\Zn" || echo -n "")"; }
function PARTITIONING_BOOT_TYPE_show()  { [[ $PARTITIONING_SCHEME != "custom" ]]; }
function PARTITIONING_BOOT_TYPE_help()  { echo "Select whether to use EFI or BIOS boot."; }
function PARTITIONING_BOOT_TYPE_menu()  {
	if menu_radiolist_labeled \
		"Select boot type" \
		"Select whether you want to use EFI or BIOS boot.$(on_off_str "$HAS_EFI_SUPPORT" "" " \Z1$EFI_UNSUPPORTED_MESSAGE\Zn")" \
		"$PARTITIONING_BOOT_TYPE" \
		"${PARTITIONING_BOOT_TYPES[@]}"
	then
		PARTITIONING_BOOT_TYPE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_BOOT_DEVICE_tag()   { echo " ├ Boot Device"; }
function PARTITIONING_BOOT_DEVICE_label() {
	local devshort=$PARTITIONING_BOOT_DEVICE
	devshort=$(shorten_device "$devshort")
	if [[ -e "$PARTITIONING_BOOT_DEVICE" ]]; then
		echo " ├ ($devshort)"
	else
		echo " ├ (\Z1$devshort\Zn)"
	fi
}
function PARTITIONING_BOOT_DEVICE_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "existing_partitions"; }
function PARTITIONING_BOOT_DEVICE_help()  { echo "The device to use for the boot partition. For EFI systems this is the efi partition. Must be formatted already."; }
function PARTITIONING_BOOT_DEVICE_menu()  {
	if menu_select_device \
		"Select boot device" \
		"Select the device containing the EFI filesystem or /boot partition respectively for systems using efi or bios boot." \
		"$PARTITIONING_BOOT_DEVICE"
	then
		PARTITIONING_BOOT_DEVICE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_USE_SWAP_tag()   { echo " ├ Use swap"; }
function PARTITIONING_USE_SWAP_label() { on_off_label "$PARTITIONING_USE_SWAP" " ├ "; }
function PARTITIONING_USE_SWAP_show()  { [[ $PARTITIONING_SCHEME != "custom" ]]; }
function PARTITIONING_USE_SWAP_help()  { echo "Select whether or not to create a swap partition."; }
function PARTITIONING_USE_SWAP_menu()  {
	on_off_toggle "PARTITIONING_USE_SWAP"
	UNSAVED_CHANGES=true
}

function PARTITIONING_SWAP_tag()   { echo " │  └ Swap amount"; }
function PARTITIONING_SWAP_label() { echo " │  └ ($PARTITIONING_SWAP)"; }
function PARTITIONING_SWAP_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && is_on "$PARTITIONING_USE_SWAP" && ! one_of "$PARTITIONING_SCHEME" "existing_partitions"; }
function PARTITIONING_SWAP_help()  { echo "Select the amount of swap to use."; }
function PARTITIONING_SWAP_menu()  {
	dialog \
		--title "Select swap amount" \
		--inputbox "Enter the amount of swap for the new system. Use the correct suffix (e.g. 16GiB, 1000MB)." \
		"${INPUTBOX_SIZE[@]}" "$PARTITIONING_SWAP" \
		|| return 0
	PARTITIONING_SWAP="$dialog_out"
	UNSAVED_CHANGES=true
}


function PARTITIONING_SWAP_DEVICE_tag()   { echo " │  └ Swap Device"; }
function PARTITIONING_SWAP_DEVICE_label() {
	local dev=${PARTITIONING_SWAP_DEVICE:-/dev/sdB}
	local devshort
	devshort=$(shorten_device "$dev")
	if [[ -e "$dev" ]]; then
		echo " │  └ ($devshort)"
	else
		echo " │  └ (\Z1$devshort\Zn)"
	fi
}
function PARTITIONING_SWAP_DEVICE_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && is_on "$PARTITIONING_USE_SWAP" && one_of "$PARTITIONING_SCHEME" "existing_partitions"; }
function PARTITIONING_SWAP_DEVICE_help()  { echo "The device to use as swap."; }
function PARTITIONING_SWAP_DEVICE_menu()  {
	if menu_select_device \
		"Select swap device" \
		"Select the device to use as swap." \
		"$PARTITIONING_SWAP_DEVICE"
	then
		PARTITIONING_SWAP_DEVICE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_ROOT_FS_tag()   { echo " ├ Root filesystem"; }
function PARTITIONING_ROOT_FS_label() { echo " ├ ($PARTITIONING_ROOT_FS)"; }
function PARTITIONING_ROOT_FS_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "classic_single_disk" "raid0_luks" "raid1_luks"; }
function PARTITIONING_ROOT_FS_help()  { echo "Select the amount of swap to use."; }
function PARTITIONING_ROOT_FS_menu()  {
	if menu_radiolist \
		"Select root fstype" \
		"Select which filesystem to use on the root partition." \
		"$PARTITIONING_ROOT_FS" \
		"${PARTITIONING_ROOT_FS_TYPES[@]}"
	then
		PARTITIONING_ROOT_FS="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_USE_LUKS_tag()   { echo " ├ LUKS Encryption"; }
function PARTITIONING_USE_LUKS_label() { on_off_label "$PARTITIONING_USE_LUKS" " ├ "; }
function PARTITIONING_USE_LUKS_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "classic_single_disk" "btrfs_centric" "raid0_luks" "raid1_luks"; }
function PARTITIONING_USE_LUKS_help()  { echo "Determines if LUKS will be used to encrypt your root partition. You can export the desired encryption key via export GENTOO_INSTALL_ENCRYPTION_KEY='...' before installing if you don't want to be asked."; }
function PARTITIONING_USE_LUKS_menu()  {
	on_off_toggle "PARTITIONING_USE_LUKS"
	UNSAVED_CHANGES=true
}

function PARTITIONING_ZFS_USE_ENCRYPTION_tag()   { echo " ├ ZFS Encryption"; }
function PARTITIONING_ZFS_USE_ENCRYPTION_label() { on_off_label "$PARTITIONING_ZFS_USE_ENCRYPTION" " ├ "; }
function PARTITIONING_ZFS_USE_ENCRYPTION_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "zfs_centric" && one_of "$PARTITIONING_ZFS_POOL_TYPE" "standard"; }
function PARTITIONING_ZFS_USE_ENCRYPTION_help()  { echo "Determines if ZFS encryption will be used to encrypt your root partition. You can export the desired encryption key via export GENTOO_INSTALL_ENCRYPTION_KEY='...' before installing if you don't want to be asked."; }
function PARTITIONING_ZFS_USE_ENCRYPTION_menu()  {
	on_off_toggle "PARTITIONING_ZFS_USE_ENCRYPTION"
	UNSAVED_CHANGES=true
}

# TODO keylocation prompt | file
# TODO if loc is file, another checkbox to "autogenerate and save new key" openssl rand -hex 32 > file

function PARTITIONING_ZFS_USE_COMPRESSION_tag()   { echo " ├ Use ZFS Compression"; }
function PARTITIONING_ZFS_USE_COMPRESSION_label() { on_off_label "$PARTITIONING_ZFS_USE_COMPRESSION" " ├ "; }
function PARTITIONING_ZFS_USE_COMPRESSION_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "zfs_centric" && one_of "$PARTITIONING_ZFS_POOL_TYPE" "standard"; }
function PARTITIONING_ZFS_USE_COMPRESSION_help()  { echo "Determines if compression should be enabled on the ZFS datasets."; }
function PARTITIONING_ZFS_USE_COMPRESSION_menu()  {
	on_off_toggle "PARTITIONING_ZFS_USE_COMPRESSION"
	UNSAVED_CHANGES=true
}

function PARTITIONING_ZFS_COMPRESSION_tag()   { echo " │  └ Compression algorithm"; }
function PARTITIONING_ZFS_COMPRESSION_label() { echo " │  └ ($PARTITIONING_ZFS_COMPRESSION)"; }
function PARTITIONING_ZFS_COMPRESSION_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "zfs_centric" && one_of "$PARTITIONING_ZFS_POOL_TYPE" "standard" && is_on "$PARTITIONING_ZFS_USE_COMPRESSION"; }
function PARTITIONING_ZFS_COMPRESSION_help()  { echo "Determines the compression algorithm used on the ZFS datasets. 'on' means to use the default compression algorithm determined by ZFS. If you need more granular control over the specific levels such as gzip-N or zstd-N, please use a custom pool."; }
function PARTITIONING_ZFS_COMPRESSION_menu()  {
	if menu_radiolist \
		"Select ZFS compression algorithm" \
		"Determines the compression algorithm used on the ZFS datasets. The special value 'on' means to use the default compression algorithm as determined by ZFS." \
		"$PARTITIONING_ZFS_COMPRESSION" \
		"${PARTITIONING_ZFS_COMPRESSIONS[@]}"
	then
		PARTITIONING_ZFS_COMPRESSION="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_ZFS_POOL_TYPE_tag()   { echo " ├ Pool type"; }
function PARTITIONING_ZFS_POOL_TYPE_label() { echo " ├ ($PARTITIONING_ZFS_POOL_TYPE)"; }
function PARTITIONING_ZFS_POOL_TYPE_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "zfs_centric"; }
function PARTITIONING_ZFS_POOL_TYPE_help()  { echo "Determines how the zfs pool will be initialized. Select 'standard' for a default pool setup that puts all given devices in one pool with ZSTD compression. Selecting 'custom' will require you to write your own pool creation function in the output config."; }
function PARTITIONING_ZFS_POOL_TYPE_menu()  {
	if menu_radiolist \
		"Select ZFS pool type" \
		"Select 'standard' for a default pool setup that puts all given devices in one pool with ZSTD compression. Selecting 'custom' will require you to write your own pool creation function in the output config." \
		"$PARTITIONING_ZFS_POOL_TYPE" \
		"${PARTITIONING_ZFS_POOL_TYPES[@]}"
	then
		PARTITIONING_ZFS_POOL_TYPE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_BTRFS_RAID_TYPE_tag()   { echo " ├ Btrfs raid type"; }
function PARTITIONING_BTRFS_RAID_TYPE_label() { echo " ├ ($PARTITIONING_BTRFS_RAID_TYPE)"; }
function PARTITIONING_BTRFS_RAID_TYPE_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "btrfs_centric"; }
function PARTITIONING_BTRFS_RAID_TYPE_help()  { echo "Determines the type of the btrfs pool."; }
function PARTITIONING_BTRFS_RAID_TYPE_menu()  {
	if menu_radiolist \
		"Select raid type" \
		"Select which raid type to use for the btrfs pool." \
		"$PARTITIONING_BTRFS_RAID_TYPE" \
		"${PARTITIONING_BTRFS_RAID_TYPES[@]}"
	then
		PARTITIONING_BTRFS_RAID_TYPE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_DEVICE_tag()   { echo " └ Device"; }
function PARTITIONING_DEVICE_label() {
	local devshort=$PARTITIONING_DEVICE
	devshort=$(shorten_device "$devshort")
	if [[ -e "$PARTITIONING_DEVICE" ]]; then
		echo " └ ($devshort)"
	else
		echo " └ (\Z1$devshort\Zn)"
	fi
}
function PARTITIONING_DEVICE_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "classic_single_disk" "existing_partitions"; }
function PARTITIONING_DEVICE_help()  { echo "The block device to which the layout will be applied."; }
function PARTITIONING_DEVICE_menu()  {
	if menu_select_device \
		"Select root device" \
		"Select the device to use as the root device." \
		"$PARTITIONING_DEVICE"
	then
		PARTITIONING_DEVICE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PARTITIONING_DEVICES_tag()   { echo " └ Devices"; }
function PARTITIONING_DEVICES_label() {
	local invalid=0
	for dev in "${PARTITIONING_DEVICES[@]}"; do
		[[ -e "$dev" ]] \
			|| ((++invalid))
	done

	if [[ "$invalid" -gt 0 ]]; then
		echo " └ (${#PARTITIONING_DEVICES[@]} devices, \Z1$invalid invalid\Zn)"
	elif [[ "${#PARTITIONING_DEVICES[@]}" -eq 1 && ("$PARTITIONING_SCHEME" == "raid0_luks" || "$PARTITIONING_SCHEME" == "raid1_luks") ]]; then
		echo " └ (${#PARTITIONING_DEVICES[@]} devices, \Z1need at least 2\Zn)"
	elif [[ "${#PARTITIONING_DEVICES[@]}" -eq 0 ]]; then
		echo " └ (${#PARTITIONING_DEVICES[@]} devices, \Z1need at least 1\Zn)"
	else
		echo " └ (${#PARTITIONING_DEVICES[@]} devices)"
	fi
}
function PARTITIONING_DEVICES_show()  { [[ $PARTITIONING_SCHEME != "custom" ]] && one_of "$PARTITIONING_SCHEME" "raid0_luks" "raid1_luks" "zfs_centric" "btrfs_centric"; }
function PARTITIONING_DEVICES_help()  { echo "The block devices to which the layout will be applied."; }
function PARTITIONING_DEVICES_menu()  {
	local invalid=()
	for dev in "${PARTITIONING_DEVICES[@]}"; do
		[[ -e "$dev" ]] \
			|| invalid+=("$dev")
	done

	local invalid_line=""
	if [[ "${#invalid[@]}" -gt 0 ]]; then
		invalid_line="\n\nInvalid devices: \Z1${invalid[*]}\Zn"
	fi

	dialog \
		--title "Select devices" \
		--inputbox "Enter the path of all devices which you want to partition, separated by space. (e.g. /dev/sda /dev/sdb).$invalid_line" \
		"${INPUTBOX_SIZE[@]}" "${PARTITIONING_DEVICES[*]}" \
		|| return 0
	read -ra PARTITIONING_DEVICES <<< "$dialog_out"
	UNSAVED_CHANGES=true
}

function HOSTNAME_tag()   { echo "Hostname"; }
function HOSTNAME_label() { echo "($HOSTNAME)"; }
function HOSTNAME_show()  { return 0; }
function HOSTNAME_help()  { echo "Enter the desired system hostname here. Be aware that when creating mdadm raid arrays, this value will be recorded in metadata block. If you change it later, you should also update the metadata."; }
function HOSTNAME_menu()  {
	dialog \
		--title "Select hostname" \
		--inputbox "Enter the hostname for your new system." \
		"${INPUTBOX_SIZE[@]}" "$HOSTNAME" \
		|| return 0
	HOSTNAME="$dialog_out"
	UNSAVED_CHANGES=true
}

function TIMEZONE_tag()   { echo "Timezone"; }
function TIMEZONE_label() { echo "($TIMEZONE)"; }
function TIMEZONE_show()  { return 0; }
function TIMEZONE_help()  { echo "The timezone for the new system."; }
function TIMEZONE_menu()  {
	# Debug: Check if timezones are available
	if [[ ${#ALL_TIMEZONES[@]} -eq 0 ]]; then
		ewarn "No timezones found! Attempting to reload timezone list..."
		get_all_timezones
		
		if [[ ${#ALL_TIMEZONES[@]} -eq 0 ]]; then
			ewarn "Still no timezones found. Checking /usr/share/zoneinfo..."
			if [[ ! -d "/usr/share/zoneinfo" ]]; then
				ewarn "/usr/share/zoneinfo directory not found!"
				dialog --msgbox "Error: Timezone data not available. Please ensure timezone data is installed." 8 60
				return 1
			fi
			
			# Try alternative timezone detection
			ewarn "Trying alternative timezone detection..."
			readarray -t ALL_TIMEZONES < <(find /usr/share/zoneinfo -type f -printf "%P\n" 2>/dev/null | sort -u)
			
			if [[ ${#ALL_TIMEZONES[@]} -eq 0 ]]; then
				ewarn "Alternative detection also failed!"
				dialog --msgbox "Error: Could not detect timezones. Please check your system." 8 60
				return 1
			fi
		fi
	fi
	
	# Debug: Show timezone count
	einfo "Found ${#ALL_TIMEZONES[@]} timezones"
	
	if menu_radiolist \
		"Select timezone" \
		"Select which timezone to use." \
		"$TIMEZONE" \
		"${ALL_TIMEZONES[@]}"
	then
		TIMEZONE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function KEYMAP_tag()   { echo "Keymap"; }
function KEYMAP_label() { echo "($KEYMAP)"; }
function KEYMAP_show()  { return 0; }
function KEYMAP_help()  { echo "The default vconsole keymap for the system."; }
function KEYMAP_menu()  {
	if menu_radiolist \
		"Select initramfs keymap" \
		"Select which keymap to use in the vconsole." \
		"$KEYMAP" \
		"${ALL_KEYMAPS[@]}"
	then
		KEYMAP="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function KEYMAP_INITRAMFS_OTHER_tag()   { echo "Different initramfs keymap"; }
function KEYMAP_INITRAMFS_OTHER_label() { on_off_label "$KEYMAP_INITRAMFS_OTHER"; }
function KEYMAP_INITRAMFS_OTHER_show()  { return 0; }
function KEYMAP_INITRAMFS_OTHER_help()  { echo "Whether another keymap should be used for the initramfs. If enabled, you will be able to choose a separate keymap below."; }
function KEYMAP_INITRAMFS_OTHER_menu()  {
	on_off_toggle "KEYMAP_INITRAMFS_OTHER"
	UNSAVED_CHANGES=true
	[[ -z $KEYMAP_INITRAMFS ]] \
		&& KEYMAP_INITRAMFS="$KEYMAP"
}

function KEYMAP_INITRAMFS_tag()   { echo " └ Keymap (initramfs)"; }
function KEYMAP_INITRAMFS_label() { echo " └ ($KEYMAP_INITRAMFS)"; }
function KEYMAP_INITRAMFS_show()  { is_on "$KEYMAP_INITRAMFS_OTHER"; }
function KEYMAP_INITRAMFS_help()  { echo "The default vconsole keymap for the initrams. This is important if need to unlock an encrypted partition when booting."; }
function KEYMAP_INITRAMFS_menu()  {
	if menu_radiolist \
		"Select initramfs keymap" \
		"Select which keymap to use in the initramfs vconsole." \
		"$KEYMAP_INITRAMFS" \
		"${ALL_KEYMAPS[@]}"
	then
		KEYMAP_INITRAMFS="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function LOCALES_tag()   { echo "Locales"; }
function LOCALES_label() { echo "$N_LOCALES selected"; }
function LOCALES_show()  { return 0; }
function LOCALES_help()  { echo "The locales to generate for the new system. Be careful that the syntax for locales is a different from the resulting name of the generated locales of locale-gen. For example, the locale 'en_US.utf8' is enabled via 'en_US.UTF-8 UTF-8')."; }
function LOCALES_menu()  {
	if menu_splitlist "Select locales" "Select which locales to generate." "$SELECTED_LOCALES" "${SUPPORTED_LOCALES[@]}"; then
		SELECTED_LOCALES="$dialog_out"
		recalculate_locales
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function LOCALE_tag()   { echo "Default locale"; }
function LOCALE_label() { echo "($LOCALE)"; }
function LOCALE_show()  { return 0; }
function LOCALE_help()  { echo "The locale to use for the new system. See \`locale -a\` for available options, and be sure to generate the locale by adding it to the list of locales above."; }
function LOCALE_menu()  {
	if menu_radiolist \
		"Select default locale" \
		"Select which locale to use as the default. Remember to also add the desired locale to the list of locales above." \
		"$LOCALE" \
		"${LOCALE_A[@]}"
	then
		LOCALE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function SYSTEMD_NETWORKD_tag()   { echo "Configure network"; }
function SYSTEMD_NETWORKD_label() { on_off_label "$SYSTEMD_NETWORKD"; }
function SYSTEMD_NETWORKD_show()  { [[ $STAGE3_VARIANT == *systemd* ]]; }
function SYSTEMD_NETWORKD_help()  { echo "Enable systemd-network to configure networking on the new system."; }
function SYSTEMD_NETWORKD_menu()  {
	on_off_toggle "SYSTEMD_NETWORKD"
	UNSAVED_CHANGES=true
}

function SYSTEMD_INITRAMFS_SSHD_tag()   { echo " ├ Enable sshd in initramfs"; }
function SYSTEMD_INITRAMFS_SSHD_label() { on_off_label "$SYSTEMD_INITRAMFS_SSHD" " ├ "; }
function SYSTEMD_INITRAMFS_SSHD_show()  { [[ $STAGE3_VARIANT == *systemd* ]] && is_on "$SYSTEMD_NETWORKD"; }
function SYSTEMD_INITRAMFS_SSHD_help()  { echo "Install and enable sshd in the initramfs. This can be used to unlock encrypted partitions / ZFS via ssh, or to get an emergency shell. Visit https://github.com/gsauthof/dracut-sshd for more information."; }
function SYSTEMD_INITRAMFS_SSHD_menu()  {
	on_off_toggle "SYSTEMD_INITRAMFS_SSHD"
	UNSAVED_CHANGES=true
}

function SYSTEMD_NETWORKD_INTERFACE_NAME_tag()   { echo " ├ Interface Name"; }
function SYSTEMD_NETWORKD_INTERFACE_NAME_label() { echo " ├ ($(ellipsis 20 "$SYSTEMD_NETWORKD_INTERFACE_NAME"))"; }
function SYSTEMD_NETWORKD_INTERFACE_NAME_show()  { [[ $STAGE3_VARIANT == *systemd* ]] && is_on "$SYSTEMD_NETWORKD"; }
function SYSTEMD_NETWORKD_INTERFACE_NAME_help()  { echo "The network interface(s) to configure. Defaults to all interfaces matching en*."; }
function SYSTEMD_NETWORKD_INTERFACE_NAME_menu()  {
	dialog \
		--title "Network Interface Name" \
		--inputbox "Enter the network interface name which should be configured. Can include wildcards." \
		"${INPUTBOX_SIZE[@]}" "$SYSTEMD_NETWORKD_INTERFACE_NAME" \
		|| return 0
	SYSTEMD_NETWORKD_INTERFACE_NAME="$dialog_out"
	UNSAVED_CHANGES=true
}

function SYSTEMD_NETWORKD_DHCP_tag()   { echo " └ Static IP"; }
function SYSTEMD_NETWORKD_DHCP_label() { on_off_label_inverted "$SYSTEMD_NETWORKD_DHCP" " └ "; }
function SYSTEMD_NETWORKD_DHCP_show()  { [[ $STAGE3_VARIANT == *systemd* ]] && is_on "$SYSTEMD_NETWORKD"; }
function SYSTEMD_NETWORKD_DHCP_help()  { echo "Use DHCP to obtain network configuration."; }
function SYSTEMD_NETWORKD_DHCP_menu()  {
	on_off_toggle "SYSTEMD_NETWORKD_DHCP"
	UNSAVED_CHANGES=true
}

function SYSTEMD_NETWORKD_ADDRESSES_tag()   { echo "   ├ Addresses"; }
function SYSTEMD_NETWORKD_ADDRESSES_label() { echo "   ├ ($(ellipsis 20 "${SYSTEMD_NETWORKD_ADDRESSES[*]}"))"; }
function SYSTEMD_NETWORKD_ADDRESSES_show()  { [[ $STAGE3_VARIANT == *systemd* ]] && is_on "$SYSTEMD_NETWORKD" && is_off "$SYSTEMD_NETWORKD_DHCP"; }
function SYSTEMD_NETWORKD_ADDRESSES_help()  { echo "A space-separated list of addresses with CIDR mask to assign to the network interface."; }
function SYSTEMD_NETWORKD_ADDRESSES_menu()  {
	dialog \
		--title "Network Addresses" \
		--inputbox "A space-separated list of addresses with CIDR mask to assign to the network interface." \
		"${INPUTBOX_SIZE[@]}" "${SYSTEMD_NETWORKD_ADDRESSES[*]}" \
		|| return 0
	# shellcheck disable=SC2206
	SYSTEMD_NETWORKD_ADDRESSES=($dialog_out)
	UNSAVED_CHANGES=true
}

function SYSTEMD_NETWORKD_GATEWAY_tag()   { echo "   └ Gateway"; }
function SYSTEMD_NETWORKD_GATEWAY_label() { echo "   └ ($(ellipsis 20 "$SYSTEMD_NETWORKD_GATEWAY"))"; }
function SYSTEMD_NETWORKD_GATEWAY_show()  { [[ $STAGE3_VARIANT == *systemd* ]] && is_on "$SYSTEMD_NETWORKD" && is_off "$SYSTEMD_NETWORKD_DHCP"; }
function SYSTEMD_NETWORKD_GATEWAY_help()  { echo "The gateway address for the network."; }
function SYSTEMD_NETWORKD_GATEWAY_menu()  {
	dialog \
		--title "Network Gateway" \
		--inputbox "The gateway address for the network." \
		"${INPUTBOX_SIZE[@]}" "$SYSTEMD_NETWORKD_GATEWAY" \
		|| return 0
	SYSTEMD_NETWORKD_GATEWAY="$dialog_out"
	UNSAVED_CHANGES=true
}

function STAGE3_VARIANT_tag()   { echo "Stage3 variant & Init system"; }
function STAGE3_VARIANT_label() { echo "($STAGE3_VARIANT)"; }
function STAGE3_VARIANT_show()  { return 0; }
function STAGE3_VARIANT_help()  { echo "Select which stage3 tarball to use. Implicitly determines whether systemd or OpenRC is used. Not all stage3 variants have been tested with this installer. The basic installation process is always the same, but due to complex profiles, unexpected blockers may arise when emerge is called. Stick to the basic choices and change after bootstrapping, unless you know how to intervene while installing."; }
function STAGE3_VARIANT_menu()  {
	if menu_radiolist_labeled \
		"Select stage3 variant" \
		"Select the base stage3 tarball variant to use for bootstrapping the system. Implicitly determines whether systemd or OpenRC is used. Not all stage3 variants have been tested with this installer. The basic installation process is always the same, but due to complex profiles, unexpected blockers may arise when emerge is called. Stick to the basic choices and change after bootstrapping, unless you know how to intervene while installing." \
		"$STAGE3_VARIANT" \
		"${ALL_STAGE3_VARIANTS[@]}"
	then
		STAGE3_VARIANT="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PORTAGE_SYNC_TYPE_tag()   { echo "Portage tree sync-type"; }
function PORTAGE_SYNC_TYPE_label() { echo "($PORTAGE_SYNC_TYPE)"; }
function PORTAGE_SYNC_TYPE_show()  { return 0; }
function PORTAGE_SYNC_TYPE_help()  { echo "The portage tree sync-type."; }
function PORTAGE_SYNC_TYPE_menu()  {
	if menu_radiolist \
		"Select sync-type" \
		"Select the portage tree sync-type. Git is generally preferred for modern system installations." \
		"$PORTAGE_SYNC_TYPE" \
		"${PORTAGE_SYNC_TYPES[@]}"
	then
		PORTAGE_SYNC_TYPE="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function PORTAGE_GIT_FULL_HISTORY_tag()   { echo " ├ Download full history"; }
function PORTAGE_GIT_FULL_HISTORY_label() { on_off_label "$PORTAGE_GIT_FULL_HISTORY" " ├ "; }
function PORTAGE_GIT_FULL_HISTORY_show()  { one_of "$PORTAGE_SYNC_TYPE" "git"; }
function PORTAGE_GIT_FULL_HISTORY_help()  { echo "Determines if the full git history of the portage tree will be downloaded. This can easily take up 1-2GB of disk space."; }
function PORTAGE_GIT_FULL_HISTORY_menu()  {
	on_off_toggle "PORTAGE_GIT_FULL_HISTORY"
	UNSAVED_CHANGES=true
}

function PORTAGE_GIT_MIRROR_tag()   { echo " └ Git mirror"; }
function PORTAGE_GIT_MIRROR_label() { echo " └ ($(ellipsis 20 "$PORTAGE_GIT_MIRROR"))"; }
function PORTAGE_GIT_MIRROR_show()  { one_of "$PORTAGE_SYNC_TYPE" "git"; }
function PORTAGE_GIT_MIRROR_help()  { echo "The portage git mirror is the git endpoint that is used to sync the portage tree. You usually should not need to change this!"; }
function PORTAGE_GIT_MIRROR_menu()  {
	dialog \
		--title "Select portage git mirror" \
		--inputbox "Enter the portage git mirror that should be used to sync the portage tree." \
		"${INPUTBOX_SIZE[@]}" "$PORTAGE_GIT_MIRROR" \
		|| return 0
	PORTAGE_GIT_MIRROR="$dialog_out"
	UNSAVED_CHANGES=true
}

function GENTOO_MIRROR_tag()   { echo "Gentoo mirror"; }
function GENTOO_MIRROR_label() { echo "($(ellipsis 20 "$GENTOO_MIRROR"))"; }
function GENTOO_MIRROR_show()  { return 0; }
function GENTOO_MIRROR_help()  { echo "Enter the initial gentoo mirror that should be used for the installation process (until mirrorselect is run)."; }
function GENTOO_MIRROR_menu()  {
	dialog \
		--title "Select gentoo mirror" \
		--inputbox "Enter the initial gentoo mirror that should be used for the system (or until mirrorselect is run). You need to enter the FULL PATH to the tree including relevant subdirectories. Leave this as it is if in doubt!" \
		"${INPUTBOX_SIZE[@]}" "$GENTOO_MIRROR" \
		|| return 0
	GENTOO_MIRROR="$dialog_out"
	UNSAVED_CHANGES=true
}

function GENTOO_ARCH_tag()   { echo "Gentoo arch"; }
function GENTOO_ARCH_label() { echo "($GENTOO_ARCH)"; }
function GENTOO_ARCH_show()  { return 0; }
function GENTOO_ARCH_help()  { echo "Select gentoo's architecture tag for the new system."; }
function GENTOO_ARCH_menu()  {
	if menu_radiolist \
		"Select architecture" \
		"Select the architecture for the new system." \
		"$GENTOO_ARCH" \
		"${ALL_GENTOO_ARCHS[@]}"
	then
		GENTOO_ARCH="$dialog_out"
		if [[ "$GENTOO_ARCH" == "x86" ]]; then
			GENTOO_SUBARCH_menu
		else
			GENTOO_SUBARCH=""
			# Return to menu
			true
		fi
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function GENTOO_SUBARCH_tag()   { echo "Gentoo sub-arch"; }
function GENTOO_SUBARCH_label() { echo "($GENTOO_SUBARCH)"; }
function GENTOO_SUBARCH_show()  { [[ "$GENTOO_ARCH" == "x86" ]]; }
function GENTOO_SUBARCH_help()  { echo "Select gentoo's sub-architecture tag for the new system."; }
function GENTOO_SUBARCH_menu()  {
	if menu_radiolist \
		"Select x86 sub-architecture" \
		"Select the specific sub-architecture for x86." \
		"$GENTOO_SUBARCH" \
		"${ALL_GENTOO_SUBARCHS[@]}"
	then
		GENTOO_SUBARCH="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function USE_PORTAGE_TESTING_tag()   { echo "Enable bleeding edge (~$GENTOO_ARCH)"; }
function USE_PORTAGE_TESTING_label() { on_off_label "$USE_PORTAGE_TESTING"; }
function USE_PORTAGE_TESTING_show()  { return 0; }
function USE_PORTAGE_TESTING_help()  { echo "Determines if the system should use bleeding edge software from the respective architecture's testing branch. This will add ACCEPT_KEYWORDS=\"~\$GENTOO_ARCH\" to /etc/portage/make.conf"; }
function USE_PORTAGE_TESTING_menu()  {
	on_off_toggle "USE_PORTAGE_TESTING"
	UNSAVED_CHANGES=true
}

function SELECT_MIRRORS_tag()   { echo "Run mirrorselect"; }
function SELECT_MIRRORS_label() { on_off_label "$SELECT_MIRRORS"; }
function SELECT_MIRRORS_show()  { return 0; }
function SELECT_MIRRORS_help()  { echo "Determines if mirrorselect will be used to determine the best gentoo mirror for the new system."; }
function SELECT_MIRRORS_menu()  {
	on_off_toggle "SELECT_MIRRORS"
	UNSAVED_CHANGES=true
}

function SELECT_MIRRORS_LARGE_FILE_tag()   { echo " └ Use large files"; }
function SELECT_MIRRORS_LARGE_FILE_label() { on_off_label "$SELECT_MIRRORS_LARGE_FILE" " └ "; }
function SELECT_MIRRORS_LARGE_FILE_show()  { is_on "$SELECT_MIRRORS"; }
function SELECT_MIRRORS_LARGE_FILE_help()  { echo "Determines if mirrorselect uses large files (~10MB) to test mirrors."; }
function SELECT_MIRRORS_LARGE_FILE_menu()  {
	on_off_toggle "SELECT_MIRRORS_LARGE_FILE"
	UNSAVED_CHANGES=true
}

function ENABLE_SSHD_tag()   { echo "Enable sshd"; }
function ENABLE_SSHD_label() { on_off_label "$ENABLE_SSHD"; }
function ENABLE_SSHD_show()  { return 0; }
function ENABLE_SSHD_help()  { echo "Install and enable sshd on the new system. A reasonably secure sshd configuration will be provided. It will by default only allow ed25519 keys, restrict key exchange algorithms to a reasonable subset, disable any password based authentication, and only allow root to login."; }
function ENABLE_SSHD_menu()  {
	on_off_toggle "ENABLE_SSHD"
	UNSAVED_CHANGES=true
}

function ENABLE_BINPKG_tag()   { echo "Enable binary packages"; }
function ENABLE_BINPKG_label() { on_off_label "$ENABLE_BINPKG"; }
function ENABLE_BINPKG_show()  { return 0; }
function ENABLE_BINPKG_help()  { echo "Use binary packages if available."; }
function ENABLE_BINPKG_menu()  {
	on_off_toggle "ENABLE_BINPKG"
	UNSAVED_CHANGES=true
}

function ROOT_SSH_AUTHORIZED_KEYS_tag()   { echo "Authorized keys (root)"; }
function ROOT_SSH_AUTHORIZED_KEYS_label() { echo "$(sed '/^\s*#/d;/^\s*$/d' <<< "$ROOT_SSH_AUTHORIZED_KEYS" | wc -l) keys"; }
function ROOT_SSH_AUTHORIZED_KEYS_show()  { return 0; }
function ROOT_SSH_AUTHORIZED_KEYS_help()  { echo "The authorized keys for ssh root login, one per line."; }
function ROOT_SSH_AUTHORIZED_KEYS_menu()  {
	# Prepare file to edit in dialog,
	# unfortunately <() won't work (probably EOF is encountered before content is available).
	local tmpfile
	tmpfile="$(mktemp)" || die "Could not create temporary file."
	cat > "$tmpfile" <<EOF
# Enter all authorized keys for ssh root login.
# Use <Tab> to navigate between the inputbox, <OK> and <Cancel>.
#
# All comments will be removed from the final file.
# If you are on a vconsole and have no means of entering this now,
# simply edit the final configuration later with a text editor.

#ssh-ed25519 ......
$ROOT_SSH_AUTHORIZED_KEYS
EOF

	dialog \
		--title "Enter authorized keys" \
		--editbox "$tmpfile" "${EDITTEXT_SIZE[@]}"
	ROOT_SSH_AUTHORIZED_KEYS="$(sed '/^\s*#/d;/^\s*$/d' <<< "$dialog_out")"
	UNSAVED_CHANGES=true
}

function DESKTOP_ENVIRONMENT_tag()   { echo "Desktop Environment"; }
function DESKTOP_ENVIRONMENT_label() { echo "(${DESKTOP_ENVIRONMENT:-none})"; }
function DESKTOP_ENVIRONMENT_show()  { return 0; }
function DESKTOP_ENVIRONMENT_help()  { echo "Choose your desktop environment. Leave empty for no DE (server/CLI only). Each DE comes with its own set of applications and tools."; }
function DESKTOP_ENVIRONMENT_menu()  {
	if menu_radiolist_labeled \
		"Select Desktop Environment" \
		"Choose your desktop environment. Each DE provides a complete graphical user interface with applications.\n\nSelect 'none' for server installations or if you prefer to install a DE manually later." \
		"${DESKTOP_ENVIRONMENT:-none}" \
		"none" "No desktop environment (server/CLI only)" \
		"kde" "KDE Plasma - Feature-rich desktop environment" \
		"gnome" "GNOME - Modern, simple desktop environment" \
		"hyprland" "Hyprland - Modern Wayland compositor" \
		"xfce" "XFCE - Lightweight desktop environment" \
		"lxqt" "LXQt - Lightweight Qt-based desktop" \
		"cinnamon" "Cinnamon - Traditional desktop environment" \
		"mate" "MATE - GNOME 2 fork" \
		"budgie" "Budgie - Modern, elegant desktop" \
		"i3" "i3 - Tiling window manager" \
		"sway" "Sway - Wayland tiling window manager" \
		"openbox" "Openbox - Lightweight window manager" \
		"fluxbox" "Fluxbox - Lightweight window manager" \
		"enlightenment" "Enlightenment - Advanced window manager" \
		"pantheon" "Pantheon - Elementary OS desktop"
	then
		DESKTOP_ENVIRONMENT="$dialog_out"
		[[ "$DESKTOP_ENVIRONMENT" == "none" ]] && DESKTOP_ENVIRONMENT=""
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function DESKTOP_ADDITIONAL_PACKAGES_tag()   { echo " ├ DE Additional packages"; }
function DESKTOP_ADDITIONAL_PACKAGES_label() { echo " ├ (${#DESKTOP_ADDITIONAL_PACKAGES[@]} packages)"; }
function DESKTOP_ADDITIONAL_PACKAGES_show()  { [[ -n "$DESKTOP_ENVIRONMENT" ]]; }
function DESKTOP_ADDITIONAL_PACKAGES_help()  { echo "Enter additional packages specific to your desktop environment that should be installed."; }
function DESKTOP_ADDITIONAL_PACKAGES_menu()  {
	dialog \
		--title "Desktop Environment Additional Packages" \
		--inputbox "Enter additional DE-specific packages (portage package ATOMs) to install. Delimited by space." \
		"${INPUTBOX_SIZE[@]}" "${DESKTOP_ADDITIONAL_PACKAGES[*]}"
	# shellcheck disable=SC2206
	DESKTOP_ADDITIONAL_PACKAGES=($dialog_out)
	UNSAVED_CHANGES=true
}

function ENABLE_DISPLAY_MANAGER_tag()   { echo " ├ Display Manager"; }
function ENABLE_DISPLAY_MANAGER_label() { echo " ├ ($ENABLE_DISPLAY_MANAGER)"; }
function ENABLE_DISPLAY_MANAGER_show()  { [[ -n "$DESKTOP_ENVIRONMENT" ]]; }
function ENABLE_DISPLAY_MANAGER_help()  { echo "Choose your display manager (login screen). 'auto' will select the best option for your chosen desktop environment."; }
function ENABLE_DISPLAY_MANAGER_menu()  {
	if menu_radiolist_labeled \
		"Select Display Manager" \
		"Choose your display manager (login screen).\n\n'auto' will automatically select the best option for your chosen desktop environment.\n\n'none' disables the display manager." \
		"$ENABLE_DISPLAY_MANAGER" \
		"auto" "Automatic (DE default)" \
		"sddm" "SDDM (KDE Plasma default)" \
		"gdm" "GDM (GNOME default)" \
		"lightdm" "LightDM (universal)" \
		"lxdm" "LXDM (lightweight)" \
		"slim" "SLiM (minimal)" \
		"none" "No display manager"
	then
		ENABLE_DISPLAY_MANAGER="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function ENABLE_NETWORK_MANAGER_tag()   { echo " ├ Network Manager"; }
function ENABLE_NETWORK_MANAGER_label() { echo " ├ ($ENABLE_NETWORK_MANAGER)"; }
function ENABLE_NETWORK_MANAGER_show()  { [[ -n "$DESKTOP_ENVIRONMENT" ]]; }
function ENABLE_NETWORK_MANAGER_help()  { echo "Choose your network manager. 'auto' will select the best option for your chosen desktop environment."; }
function ENABLE_NETWORK_MANAGER_menu()  {
	if menu_radiolist_labeled \
		"Select Network Manager" \
		"Choose your network manager.\n\n'auto' will automatically select the best option for your chosen desktop environment.\n\n'none' disables the network manager." \
		"$ENABLE_NETWORK_MANAGER" \
		"auto" "Automatic (DE default)" \
		"networkmanager" "NetworkManager (recommended)" \
		"connman" "ConnMan (lightweight)" \
		"wicd" "Wicd (minimal)" \
		"none" "No network manager"
	then
		ENABLE_NETWORK_MANAGER="$dialog_out"
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function GPU_DRIVER_tag()   { echo "GPU Driver"; }
function GPU_DRIVER_label() { echo "(${GPU_DRIVER:-auto})"; }
function GPU_DRIVER_show()  { return 0; }
function GPU_DRIVER_help()  { echo "Choose your GPU driver. 'auto' will select the best driver for your chosen desktop environment. Mesa drivers are recommended for maximum compatibility."; }
function GPU_DRIVER_menu()  {
	if menu_radiolist_labeled \
		"Select GPU Driver" \
		"Choose your GPU driver.\n\n'auto' will automatically select the best driver for your chosen desktop environment.\n\nMesa drivers are recommended for maximum compatibility and Wayland support.\n\nNVIDIA proprietary drivers offer best performance but are closed source." \
		"${GPU_DRIVER:-auto}" \
		"auto" "Automatic (DE recommendation)" \
		"mesa" "Universal Mesa drivers (open-source, best compatibility)" \
		"amd" "AMD GPU drivers (Mesa-based, recommended for AMD cards)" \
		"intel" "Intel GPU drivers (Mesa-based, recommended for Intel cards)" \
		"nvidia" "NVIDIA proprietary drivers (best performance, closed source)" \
		"nvidia-nvk" "NVIDIA open-source drivers (NVK, experimental)" \
		"nouveau" "NVIDIA open-source drivers (Nouveau, good compatibility)" \
		"none" "No GPU drivers (server/CLI only)"
	then
		GPU_DRIVER="$dialog_out"
		[[ "$GPU_DRIVER" == "auto" ]] && GPU_DRIVER=""
		UNSAVED_CHANGES=true
	else
		# Return to menu
		true
	fi
}

function GPU_DRIVER_ADDITIONAL_PACKAGES_tag()   { echo " ├ GPU Additional packages"; }
function GPU_DRIVER_ADDITIONAL_PACKAGES_label() { echo " ├ (${#GPU_DRIVER_ADDITIONAL_PACKAGES[@]} packages)"; }
function GPU_DRIVER_ADDITIONAL_PACKAGES_show()  { [[ -n "$GPU_DRIVER" ]]; }
function GPU_DRIVER_ADDITIONAL_PACKAGES_help()  { echo "Enter additional GPU driver packages that should be installed."; }
function GPU_DRIVER_ADDITIONAL_PACKAGES_menu()  {
	dialog \
		--title "GPU Driver Additional Packages" \
		--inputbox "Enter additional GPU driver packages (portage package ATOMs) to install. Delimited by space." \
		"${INPUTBOX_SIZE[@]}" "${GPU_DRIVER_ADDITIONAL_PACKAGES[*]}"
	# shellcheck disable=SC2206
	GPU_DRIVER_ADDITIONAL_PACKAGES=($dialog_out)
	UNSAVED_CHANGES=true
}

function ENABLE_VULKAN_tag()   { echo " ├ Enable Vulkan"; }
function ENABLE_VULKAN_label() { echo " ├ ($(on_off_label ENABLE_VULKAN))"; }
function ENABLE_VULKAN_show()  { [[ -n "$GPU_DRIVER" ]]; }
function ENABLE_VULKAN_help()  { echo "Enable Vulkan support for GPU drivers. Recommended for gaming and modern applications."; }
function ENABLE_VULKAN_menu()  {
	on_off_toggle ENABLE_VULKAN
	UNSAVED_CHANGES=true
}

function ENABLE_OPENCL_tag()   { echo " ├ Enable OpenCL"; }
function ENABLE_OPENCL_label() { echo " ├ ($(on_off_label ENABLE_OPENCL))"; }
function ENABLE_OPENCL_show()  { [[ -n "$GPU_DRIVER" ]]; }
function ENABLE_OPENCL_help()  { echo "Enable OpenCL support for GPU drivers. Useful for compute applications and some games."; }
function ENABLE_OPENCL_menu()  {
	on_off_toggle ENABLE_OPENCL
	UNSAVED_CHANGES=true
}

function ENABLE_PERFORMANCE_OPTIMIZATION_tag()   { echo "Performance Optimization"; }
function ENABLE_PERFORMANCE_OPTIMIZATION_label() { echo "($(on_off_label ENABLE_PERFORMANCE_OPTIMIZATION))"; }
function ENABLE_PERFORMANCE_OPTIMIZATION_show()  { return 0; }
function ENABLE_PERFORMANCE_OPTIMIZATION_help()  { echo "Enable performance optimization features including CPU tuning, memory optimization, and system tweaks for better VM performance."; }
function ENABLE_PERFORMANCE_OPTIMIZATION_menu()  {
	on_off_toggle ENABLE_PERFORMANCE_OPTIMIZATION
	UNSAVED_CHANGES=true
}

function ENABLE_VM_TESTING_TOOLS_tag()   { echo "VM Testing Tools"; }
function ENABLE_VM_TESTING_TOOLS_label() { echo "($(on_off_label ENABLE_VM_TESTING_TOOLS))"; }
function ENABLE_VM_TESTING_TOOLS_show()  { return 0; }
function ENABLE_VM_TESTING_TOOLS_help()  { echo "Install comprehensive VM testing and management tools including launchers, performance monitors, and configuration utilities."; }
function ENABLE_VM_TESTING_TOOLS_menu()  {
	on_off_toggle ENABLE_VM_TESTING_TOOLS
	UNSAVED_CHANGES=true
}

function ENABLE_DISPLAY_BACKEND_TESTING_tag()   { echo "Display Backend Testing"; }
function ENABLE_DISPLAY_BACKEND_TESTING_label() { echo "($(on_off_label ENABLE_DISPLAY_BACKEND_TESTING))"; }
function ENABLE_DISPLAY_BACKEND_TESTING_show()  { [[ -n "$GPU_DRIVER" ]]; }
function ENABLE_DISPLAY_BACKEND_TESTING_help()  { echo "Enable display backend testing tools for optimizing GTK, SDL, and SPICE performance in VM environments."; }
function ENABLE_DISPLAY_BACKEND_TESTING_menu()  {
	on_off_toggle ENABLE_DISPLAY_BACKEND_TESTING
	UNSAVED_CHANGES=true
}

function ENABLE_GPU_BENCHMARKING_tag()   { echo "GPU Benchmarking"; }
function ENABLE_GPU_BENCHMARKING_label() { echo "($(on_off_label ENABLE_GPU_BENCHMARKING))"; }
function ENABLE_GPU_BENCHMARKING_show()  { [[ -n "$GPU_DRIVER" ]]; }
function ENABLE_GPU_BENCHMARKING_help()  { echo "Enable GPU benchmarking tools for performance testing and optimization in VM environments."; }
function ENABLE_GPU_BENCHMARKING_menu()  {
	on_off_toggle ENABLE_GPU_BENCHMARKING
	UNSAVED_CHANGES=true
}

function ADDITIONAL_PACKAGES_tag()   { echo "Additional packages"; }
function ADDITIONAL_PACKAGES_label() { echo "${#ADDITIONAL_PACKAGES[@]} packages"; }
function ADDITIONAL_PACKAGES_show()  { return 0; }
function ADDITIONAL_PACKAGES_help()  { echo "Enter additional packages that should be installed. It is recommended to keep this to a minimum, because of the quite \"interactive\" nature of gentoo package management ;)"; }
function ADDITIONAL_PACKAGES_menu()  {
	dialog \
		--title "Additional packages" \
		--inputbox "Enter additional packages (portage package ATOMs) to install. Delimited by space." \
		"${INPUTBOX_SIZE[@]}" "${ADDITIONAL_PACKAGES[*]}"
	# shellcheck disable=SC2206
	ADDITIONAL_PACKAGES=($dialog_out)
	UNSAVED_CHANGES=true
}

################################################
# Package Management Functions

function PACKAGE_USE_RULES_tag()   { echo "Package USE rules"; }
function PACKAGE_USE_RULES_label() { echo "${#PACKAGE_USE_RULES[@]} rules"; }
function PACKAGE_USE_RULES_show()  { return 0; }
function PACKAGE_USE_RULES_help()  { echo "Configure package USE flags. Format: package atom followed by USE flags (e.g., 'dev-lang/python -tk +sqlite')."; }
function PACKAGE_USE_RULES_menu()  {
	package_use_rules_manager
}

function PACKAGE_KEYWORDS_tag()   { echo "Package keywords"; }
function PACKAGE_KEYWORDS_label() { echo "${#PACKAGE_KEYWORDS[@]} keywords"; }
function PACKAGE_KEYWORDS_show()  { return 0; }
function PACKAGE_KEYWORDS_help()  { echo "Configure package keywords for testing/unstable packages. Format: package atom followed by keywords (e.g., 'dev-lang/python ~amd64')."; }
function PACKAGE_KEYWORDS_menu()  {
	package_keywords_manager
}

function ACCEPT_KEYWORDS_tag()   { echo "Accept keywords"; }
function ACCEPT_KEYWORDS_label() { echo "${#ACCEPT_KEYWORDS[@]} keywords"; }
function ACCEPT_KEYWORDS_show()  { return 0; }
function ACCEPT_KEYWORDS_help()  { echo "Configure global ACCEPT_KEYWORDS for testing/unstable packages. Format: keywords separated by space (e.g., '~amd64 ~x86')."; }
function ACCEPT_KEYWORDS_menu()  {
	accept_keywords_manager
}

function OVERLAY_MANAGER_tag()   { echo "Portage overlays"; }
function OVERLAY_MANAGER_label() { echo "${#OVERLAY_URLS[@]} overlays"; }
function OVERLAY_MANAGER_show()  { return 0; }
function OVERLAY_MANAGER_help()  { echo "Manage portage overlays (layman repositories). Add, remove, or configure overlay sources."; }
function OVERLAY_MANAGER_menu()  {
	overlay_manager
}

# Package USE rules manager
function package_use_rules_manager() {
	local action
	local current_rules=("${PACKAGE_USE_RULES[@]}")
	
	while true; do
		# Create action menu
		local actions=("add" "edit" "remove" "view" "back")
		local action_labels=("Add rule" "Edit rule" "Remove rule" "View rules" "Back to main menu")
		
		dialog \
			--title "Package USE Rules Manager" \
			--menu "Select an action:" \
			"${MENU_SIZE[@]}" \
			"${#actions[@]}" \
			"${actions[@]}" \
			"${action_labels[@]}"
		
		action="$dialog_out"
		
		case "$action" in
			"add")
				local package_atom use_flags
				dialog \
					--title "Add USE Rule" \
					--form "Enter package atom and USE flags:" \
					"${INPUTBOX_SIZE[@]}" \
					"Package atom:" 1 1 "" 1 20 50 0 \
					"USE flags:" 2 1 "" 2 20 50 0
				
				package_atom="$(echo "$dialog_out" | head -1)"
				use_flags="$(echo "$dialog_out" | tail -1)"
				
				if [[ -n "$package_atom" && -n "$use_flags" ]]; then
					PACKAGE_USE_RULES+=("$package_atom $use_flags")
					UNSAVED_CHANGES=true
					dialog --msgbox "USE rule added successfully!" 6 50
				fi
				;;
			"edit")
				if [[ ${#PACKAGE_USE_RULES[@]} -eq 0 ]]; then
					dialog --msgbox "No USE rules to edit." 6 40
					continue
				fi
				
				local rule_index
				local rules_display=()
				for i in "${!PACKAGE_USE_RULES[@]}"; do
					rules_display+=("$i" "${PACKAGE_USE_RULES[$i]}")
				done
				
				dialog \
					--title "Edit USE Rule" \
					--menu "Select rule to edit:" \
					"${MENU_SIZE[@]}" \
					"${#rules_display[@]}" \
					"${rules_display[@]}"
				
				rule_index="$dialog_out"
				if [[ -n "$rule_index" ]]; then
					local new_rule
					dialog \
						--title "Edit USE Rule" \
						--inputbox "Edit USE rule:" \
						"${INPUTBOX_SIZE[@]}" \
						"${PACKAGE_USE_RULES[$rule_index]}"
					
					new_rule="$dialog_out"
					if [[ -n "$new_rule" ]]; then
						PACKAGE_USE_RULES[$rule_index]="$new_rule"
						UNSAVED_CHANGES=true
						dialog --msgbox "USE rule updated successfully!" 6 50
					fi
				fi
				;;
			"remove")
				if [[ ${#PACKAGE_USE_RULES[@]} -eq 0 ]]; then
					dialog --msgbox "No USE rules to remove." 6 40
					continue
				fi
				
				local rule_index
				local rules_display=()
				for i in "${!PACKAGE_USE_RULES[@]}"; do
					rules_display+=("$i" "${PACKAGE_USE_RULES[$i]}")
				done
				
				dialog \
					--title "Remove USE Rule" \
					--menu "Select rule to remove:" \
					"${MENU_SIZE[@]}" \
					"${#rules_display[@]}" \
					"${rules_display[@]}"
				
				rule_index="$dialog_out"
				if [[ -n "$rule_index" ]]; then
					unset "PACKAGE_USE_RULES[$rule_index]"
					PACKAGE_USE_RULES=("${PACKAGE_USE_RULES[@]}")
					UNSAVED_CHANGES=true
					dialog --msgbox "USE rule removed successfully!" 6 50
				fi
				;;
			"view")
				if [[ ${#PACKAGE_USE_RULES[@]} -eq 0 ]]; then
					dialog --msgbox "No USE rules configured." 6 40
				else
					local rules_text=""
					for i in "${!PACKAGE_USE_RULES[@]}"; do
						rules_text+="$((i+1)). ${PACKAGE_USE_RULES[$i]}\n"
					done
					
					dialog \
						--title "Current USE Rules" \
						--scrolltext \
						"${HELP_POPUP_SIZE[@]}" \
						"$rules_text"
				fi
				;;
			"back")
				return 0
				;;
		esac
	done
}

# Package keywords manager
function package_keywords_manager() {
	local action
	local current_keywords=("${PACKAGE_KEYWORDS[@]}")
	
	while true; do
		# Create action menu
		local actions=("add" "edit" "remove" "view" "back")
		local action_labels=("Add keyword" "Edit keyword" "Remove keyword" "View keywords" "Back to main menu")
		
		dialog \
			--title "Package Keywords Manager" \
			--menu "Select an action:" \
			"${MENU_SIZE[@]}" \
			"${#actions[@]}" \
			"${actions[@]}" \
			"${action_labels[@]}"
		
		action="$dialog_out"
		
		case "$action" in
			"add")
				local package_atom keywords
				dialog \
					--title "Add Package Keyword" \
					--form "Enter package atom and keywords:" \
					"${INPUTBOX_SIZE[@]}" \
					"Package atom:" 1 1 "" 1 20 50 0 \
					"Keywords:" 2 1 "" 2 20 50 0
				
				package_atom="$(echo "$dialog_out" | head -1)"
				keywords="$(echo "$dialog_out" | tail -1)"
				
				if [[ -n "$package_atom" && -n "$keywords" ]]; then
					PACKAGE_KEYWORDS+=("$package_atom $keywords")
					UNSAVED_CHANGES=true
					dialog --msgbox "Package keyword added successfully!" 6 50
				fi
				;;
			"edit")
				if [[ ${#PACKAGE_KEYWORDS[@]} -eq 0 ]]; then
					dialog --msgbox "No package keywords to edit." 6 40
					continue
				fi
				
				local keyword_index
				local keywords_display=()
				for i in "${!PACKAGE_KEYWORDS[@]}"; do
					keywords_display+=("$i" "${PACKAGE_KEYWORDS[$i]}")
				done
				
				dialog \
					--title "Edit Package Keyword" \
					--menu "Select keyword to edit:" \
					"${INPUTBOX_SIZE[@]}" \
					"${#keywords_display[@]}" \
					"${keywords_display[@]}"
				
				keyword_index="$dialog_out"
				if [[ -n "$keyword_index" ]]; then
					local new_keyword
					dialog \
						--title "Edit Package Keyword" \
						--inputbox "Edit package keyword:" \
						"${INPUTBOX_SIZE[@]}" \
						"${PACKAGE_KEYWORDS[$keyword_index]}"
					
					new_keyword="$dialog_out"
					if [[ -n "$new_keyword" ]]; then
						PACKAGE_KEYWORDS[$keyword_index]="$new_keyword"
						UNSAVED_CHANGES=true
						dialog --msgbox "Package keyword updated successfully!" 6 50
					fi
				fi
				;;
			"remove")
				if [[ ${#PACKAGE_KEYWORDS[@]} -eq 0 ]]; then
					dialog --msgbox "No package keywords to remove." 6 40
					continue
				fi
				
				local keyword_index
				local keywords_display=()
				for i in "${!PACKAGE_KEYWORDS[@]}"; do
					keywords_display+=("$i" "${PACKAGE_KEYWORDS[$i]}")
				done
				
				dialog \
					--title "Remove Package Keyword" \
					--menu "Select keyword to remove:" \
					"${MENU_SIZE[@]}" \
					"${#keywords_display[@]}" \
					"${keywords_display[@]}"
				
				keyword_index="$dialog_out"
				if [[ -n "$keyword_index" ]]; then
					unset "PACKAGE_KEYWORDS[$keyword_index]"
					PACKAGE_KEYWORDS=("${PACKAGE_KEYWORDS[@]}")
					UNSAVED_CHANGES=true
					dialog --msgbox "Package keyword removed successfully!" 6 50
				fi
				;;
			"view")
				if [[ ${#PACKAGE_KEYWORDS[@]} -eq 0 ]]; then
					dialog --msgbox "No package keywords configured." 6 40
				else
					local keywords_text=""
					for i in "${!PACKAGE_KEYWORDS[@]}"; do
						keywords_text+="$((i+1)). ${PACKAGE_KEYWORDS[$i]}\n"
					done
					
					dialog \
						--title "Current Package Keywords" \
						--scrolltext \
						"${HELP_POPUP_SIZE[@]}" \
						"$keywords_text"
				fi
				;;
			"back")
				return 0
				;;
		esac
	done
}

# Accept keywords manager
function accept_keywords_manager() {
	local action
	local current_keywords=("${ACCEPT_KEYWORDS[@]}")
	
	while true; do
		# Create action menu
		local actions=("add" "edit" "remove" "view" "back")
		local action_labels=("Add keyword" "Edit keyword" "Remove keyword" "View keywords" "Back to main menu")
		
		dialog \
			--title "Accept Keywords Manager" \
			--menu "Select an action:" \
			"${MENU_SIZE[@]}" \
			"${#actions[@]}" \
			"${actions[@]}" \
			"${action_labels[@]}"
		
		action="$dialog_out"
		
		case "$action" in
			"add")
				local keyword
				dialog \
					--title "Add Accept Keyword" \
					--inputbox "Enter keyword to accept (e.g., ~amd64):" \
					"${INPUTBOX_SIZE[@]}" \
					""
				
				keyword="$dialog_out"
				if [[ -n "$keyword" ]]; then
					ACCEPT_KEYWORDS+=("$keyword")
					UNSAVED_CHANGES=true
					dialog --msgbox "Accept keyword added successfully!" 6 50
				fi
				;;
			"edit")
				if [[ ${#ACCEPT_KEYWORDS[@]} -eq 0 ]]; then
					dialog --msgbox "No accept keywords to edit." 6 40
					continue
				fi
				
				local keyword_index
				local keywords_display=()
				for i in "${!ACCEPT_KEYWORDS[@]}"; do
					keywords_display+=("$i" "${ACCEPT_KEYWORDS[$i]}")
				done
				
				dialog \
					--title "Edit Accept Keyword" \
					--menu "Select keyword to edit:" \
					"${MENU_SIZE[@]}" \
					"${#keywords_display[@]}" \
					"${keywords_display[@]}"
				
				keyword_index="$dialog_out"
				if [[ -n "$keyword_index" ]]; then
					local new_keyword
					dialog \
						--title "Edit Accept Keyword" \
						--inputbox "Edit accept keyword:" \
						"${INPUTBOX_SIZE[@]}" \
						"${ACCEPT_KEYWORDS[$keyword_index]}"
					
					new_keyword="$dialog_out"
					if [[ -n "$new_keyword" ]]; then
						ACCEPT_KEYWORDS[$keyword_index]="$new_keyword"
						UNSAVED_CHANGES=true
						dialog --msgbox "Accept keyword updated successfully!" 6 50
					fi
				fi
				;;
			"remove")
				if [[ ${#ACCEPT_KEYWORDS[@]} -eq 0 ]]; then
					dialog --msgbox "No accept keywords to remove." 6 40
					continue
				fi
				
				local keyword_index
				local keywords_display=()
				for i in "${!ACCEPT_KEYWORDS[@]}"; do
					keywords_display+=("$i" "${ACCEPT_KEYWORDS[$i]}")
				done
				
				dialog \
					--title "Remove Accept Keyword" \
					--menu "Select keyword to remove:" \
					"${MENU_SIZE[@]}" \
					"${#keywords_display[@]}" \
					"${keywords_display[@]}"
				
				keyword_index="$dialog_out"
				if [[ -n "$keyword_index" ]]; then
					unset "ACCEPT_KEYWORDS[$keyword_index]"
					ACCEPT_KEYWORDS=("${ACCEPT_KEYWORDS[@]}")
					UNSAVED_CHANGES=true
					dialog --msgbox "Accept keyword removed successfully!" 6 50
				fi
				;;
			"view")
				if [[ ${#ACCEPT_KEYWORDS[@]} -eq 0 ]]; then
					dialog --msgbox "No accept keywords configured." 6 40
				else
					local keywords_text=""
					for i in "${!ACCEPT_KEYWORDS[@]}"; do
						keywords_text+="$((i+1)). ${ACCEPT_KEYWORDS[$i]}\n"
					done
					
					dialog \
						--title "Current Accept Keywords" \
						--scrolltext \
						"${HELP_POPUP_SIZE[@]}" \
						"$keywords_text"
				fi
				;;
			"back")
				return 0
				;;
		esac
	done
}

# Overlay manager
function overlay_manager() {
	local action
	local current_overlays=("${OVERLAY_URLS[@]}")
	
	while true; do
		# Create action menu
		local actions=("add" "edit" "remove" "view" "back")
		local action_labels=("Add overlay" "Edit overlay" "Remove overlay" "View overlays" "Back to main menu")
		
		dialog \
			--title "Overlay Manager" \
			--menu "Select an action:" \
			"${MENU_SIZE[@]}" \
			"${#actions[@]}" \
			"${actions[@]}" \
			"${action_labels[@]}"
		
		action="$dialog_out"
		
		case "$action" in
			"add")
				local overlay_url overlay_name
				dialog \
					--title "Add Overlay" \
					--form "Enter overlay URL and name:" \
					"${INPUTBOX_SIZE[@]}" \
					"Overlay URL:" 1 1 "" 1 20 50 0 \
					"Overlay name:" 2 1 "" 2 20 50 0
				
				overlay_url="$(echo "$dialog_out" | head -1)"
				overlay_name="$(echo "$dialog_out" | tail -1)"
				
				if [[ -n "$overlay_url" && -n "$overlay_name" ]]; then
					OVERLAY_URLS+=("$overlay_url")
					OVERLAY_NAMES+=("$overlay_name")
					UNSAVED_CHANGES=true
					dialog --msgbox "Overlay added successfully!" 6 50
				fi
				;;
			"edit")
				if [[ ${#OVERLAY_URLS[@]} -eq 0 ]]; then
					dialog --msgbox "No overlays to edit." 6 40
					continue
				fi
				
				local overlay_index
				local overlays_display=()
				for i in "${!OVERLAY_URLS[@]}"; do
					overlays_display+=("$i" "${OVERLAY_NAMES[$i]} (${OVERLAY_URLS[$i]})")
				done
				
				dialog \
					--title "Edit Overlay" \
					--menu "Select overlay to edit:" \
					"${MENU_SIZE[@]}" \
					"${#overlays_display[@]}" \
					"${overlays_display[@]}"
				
				overlay_index="$dialog_out"
				if [[ -n "$overlay_index" ]]; then
					local new_url new_name
					dialog \
						--title "Edit Overlay" \
						--form "Edit overlay URL and name:" \
						"${INPUTBOX_SIZE[@]}" \
						"Overlay URL:" 1 1 "" 1 20 50 0 \
						"Overlay name:" 2 1 "" 2 20 50 0
					
					new_url="$(echo "$dialog_out" | head -1)"
					new_name="$(echo "$dialog_out" | tail -1)"
					
					if [[ -n "$new_url" && -n "$new_name" ]]; then
						OVERLAY_URLS[$overlay_index]="$new_url"
						OVERLAY_NAMES[$overlay_index]="$new_name"
						UNSAVED_CHANGES=true
						dialog --msgbox "Overlay updated successfully!" 6 50
					fi
				fi
				;;
			"remove")
				if [[ ${#OVERLAY_URLS[@]} -eq 0 ]]; then
					dialog --msgbox "No overlays to remove." 6 40
					continue
				fi
				
				local overlay_index
				local overlays_display=()
				for i in "${!OVERLAY_URLS[@]}"; do
					overlays_display+=("$i" "${OVERLAY_NAMES[$i]} (${OVERLAY_URLS[$i]})")
				done
				
				dialog \
					--title "Remove Overlay" \
					--menu "Select overlay to remove:" \
					"${MENU_SIZE[@]}" \
					"${#overlays_display[@]}" \
					"${overlays_display[@]}"
				
				overlay_index="$dialog_out"
				if [[ -n "$overlay_index" ]]; then
					unset "OVERLAY_URLS[$overlay_index]"
					unset "OVERLAY_NAMES[$overlay_index]"
					OVERLAY_URLS=("${OVERLAY_URLS[@]}")
					OVERLAY_NAMES=("${OVERLAY_NAMES[@]}")
					UNSAVED_CHANGES=true
					dialog --msgbox "Overlay removed successfully!" 6 50
				fi
				;;
			"view")
				if [[ ${#OVERLAY_URLS[@]} -eq 0 ]]; then
					dialog --msgbox "No overlays configured." 6 40
				else
					local overlays_text=""
					for i in "${!OVERLAY_URLS[@]}"; do
						overlays_text+="$((i+1)). ${OVERLAY_NAMES[$i]} (${OVERLAY_URLS[$i]})\n"
					done
					
					dialog \
						--title "Current Overlays" \
						--scrolltext \
						"${HELP_POPUP_SIZE[@]}" \
						"$overlays_text"
				fi
				;;
			"back")
				return 0
				;;
		esac
	done
}


################################################
# Menu functions

# $1: filename
function save() {
	if [[ "$KEYMAP_INITRAMFS_OTHER" == "false" ]]; then
		KEYMAP_INITRAMFS="$KEYMAP"
	fi

	cat > "$1" <<EOF
# vim: set ft=sh ts=4 sw=4 sts=-1 noet:
# This file will be interpreted by /bin/bash.


################################################
# Disk configuration

$(define_disk_layout)


################################################
# System configuration

HOSTNAME=${HOSTNAME@Q}
TIMEZONE=${TIMEZONE@Q}
KEYMAP=${KEYMAP@Q}
KEYMAP_INITRAMFS=${KEYMAP_INITRAMFS@Q}

LOCALES=${LOCALES@Q}
LOCALE=${LOCALE@Q}

SYSTEMD_NETWORKD=${SYSTEMD_NETWORKD@Q}
SYSTEMD_NETWORKD_INTERFACE_NAME=${SYSTEMD_NETWORKD_INTERFACE_NAME@Q}
SYSTEMD_NETWORKD_DHCP=${SYSTEMD_NETWORKD_DHCP@Q}
SYSTEMD_NETWORKD_ADDRESSES=${SYSTEMD_NETWORKD_ADDRESSES@Q}
SYSTEMD_NETWORKD_GATEWAY=${SYSTEMD_NETWORKD_GATEWAY@Q}
SYSTEMD_INITRAMFS_SSHD=${SYSTEMD_INITRAMFS_SSHD@Q}


################################################
# Gentoo configuration

PORTAGE_SYNC_TYPE=${PORTAGE_SYNC_TYPE@Q}
PORTAGE_GIT_FULL_HISTORY=${PORTAGE_GIT_FULL_HISTORY@Q}
PORTAGE_GIT_MIRROR=${PORTAGE_GIT_MIRROR@Q}
GENTOO_MIRROR=${GENTOO_MIRROR@Q}
GENTOO_ARCH=${GENTOO_ARCH@Q}
GENTOO_SUBARCH=${GENTOO_SUBARCH@Q}
STAGE3_VARIANT=${STAGE3_VARIANT@Q}
STAGE3_BASENAME="stage3-\$GENTOO_ARCH-\$STAGE3_VARIANT"
STAGE3_BASENAME_CUSTOM=\$([[ \$STAGE3_VARIANT == *x32* ]] && echo "stage3-$STAGE3_VARIANT" || echo "stage3-$GENTOO_SUBARCH-$STAGE3_VARIANT")
USE_PORTAGE_TESTING=${USE_PORTAGE_TESTING@Q}
SELECT_MIRRORS=${SELECT_MIRRORS@Q}
SELECT_MIRRORS_LARGE_FILE=${SELECT_MIRRORS_LARGE_FILE@Q}
SYSTEMD=\$([[ \$STAGE3_VARIANT == *systemd* ]] && echo "true" || echo "false")
MUSL=\$([[ \$STAGE3_VARIANT == *musl* ]] && echo "true" || echo "false")


################################################
# Additional (optional) configuration

ADDITIONAL_PACKAGES=(${ADDITIONAL_PACKAGES[@]@Q})
ENABLE_SSHD=${ENABLE_SSHD@Q}
ENABLE_BINPKG=${ENABLE_BINPKG@Q}
ROOT_SSH_AUTHORIZED_KEYS=${ROOT_SSH_AUTHORIZED_KEYS@Q}


################################################
# Desktop Environment Configuration

DESKTOP_ENVIRONMENT=${DESKTOP_ENVIRONMENT@Q}
DESKTOP_ADDITIONAL_PACKAGES=(${DESKTOP_ADDITIONAL_PACKAGES[@]@Q})
ENABLE_DISPLAY_MANAGER=${ENABLE_DISPLAY_MANAGER@Q}
ENABLE_NETWORK_MANAGER=${ENABLE_NETWORK_MANAGER@Q}


################################################
# GPU Driver Configuration

GPU_DRIVER=${GPU_DRIVER@Q}
GPU_DRIVER_ADDITIONAL_PACKAGES=(${GPU_DRIVER_ADDITIONAL_PACKAGES[@]@Q})
ENABLE_VULKAN=${ENABLE_VULKAN@Q}
ENABLE_OPENCL=${ENABLE_OPENCL@Q}


################################################
# Performance & Testing Configuration

ENABLE_PERFORMANCE_OPTIMIZATION=${ENABLE_PERFORMANCE_OPTIMIZATION@Q}
ENABLE_VM_TESTING_TOOLS=${ENABLE_VM_TESTING_TOOLS@Q}
ENABLE_DISPLAY_BACKEND_TESTING=${ENABLE_DISPLAY_BACKEND_TESTING@Q}
ENABLE_GPU_BENCHMARKING=${ENABLE_GPU_BENCHMARKING@Q}


################################################
# Package Management Configuration

PACKAGE_USE_RULES=(${PACKAGE_USE_RULES[@]@Q})
PACKAGE_KEYWORDS=(${PACKAGE_KEYWORDS[@]@Q})
ACCEPT_KEYWORDS=(${ACCEPT_KEYWORDS[@]@Q})
OVERLAY_URLS=(${OVERLAY_URLS[@]@Q})
OVERLAY_NAMES=(${OVERLAY_NAMES[@]@Q})


################################################
# Prove that you have read the config

I_HAVE_READ_AND_EDITED_THE_CONFIG_PROPERLY=true
EOF
}

trap 'clear_and_exit 130' SIGINT

# Begin menu loop. Exit will be called to end this loop where it is appropriate.
while true; do
	menu
done
